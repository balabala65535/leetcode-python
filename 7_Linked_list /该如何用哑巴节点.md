### **何时使用哑巴节点（Dummy Node）？——链表题的最强辅助技巧**

在解决链表问题时，**哑巴节点（Dummy Node）** 是一个极其重要的技巧，它能帮你**简化边界条件处理**，尤其是当链表可能被修改（如删除节点、反转链表、合并链表）时。以下是它的核心使用场景和详细解释：

---

## **一、哑巴节点的作用**
哑巴节点是一个**虚拟的头节点**（不存储实际数据），它的 `next` 指向真正的链表头。它的核心价值是：
1. **避免处理空链表的特殊情况**（比如 `head is None`）。
2. **统一头节点和其他节点的操作逻辑**（比如删除头节点时不需要额外判断）。
3. **在需要返回新链表时，方便记录结果链表的头**。

---

## **二、必须使用哑巴节点的场景**
### **1. 需要删除头节点时**
**问题示例**：  
[203. 移除链表元素](https://leetcode.com/problems/remove-linked-list-elements/)  
> 删除链表中所有值为 `val` 的节点。

**普通写法（需特殊处理头节点）**：
```python
def removeElements(head, val):
    # 先处理头节点可能需要被删除的情况
    while head and head.val == val:
        head = head.next
    if not head:
        return None
    # 再处理其他节点
    curr = head
    while curr.next:
        if curr.next.val == val:
            curr.next = curr.next.next
        else:
            curr = curr.next
    return head
```

**哑巴节点写法（逻辑统一）**：
```python
def removeElements(head, val):
    dummy = ListNode(next=head)  # 哑巴节点指向 head
    curr = dummy
    while curr.next:
        if curr.next.val == val:
            curr.next = curr.next.next
        else:
            curr = curr.next
    return dummy.next  # 返回哑巴节点的 next（可能是新头节点）
```
**为什么更好？**  
- 不需要单独处理 `head` 被删除的情况。
- `curr` 始终指向待处理节点的前驱，逻辑更清晰。

---

### **2. 合并两个有序链表**
**问题示例**：  
[21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/)  
> 将两个升序链表合并为一个新的升序链表。

**普通写法（需判断哪个链表头更小）**：
```python
def mergeTwoLists(l1, l2):
    if not l1 or not l2:
        return l1 or l2
    # 需要先确定头节点
    if l1.val < l2.val:
        head = l1
        l1 = l1.next
    else:
        head = l2
        l2 = l2.next
    curr = head
    # 再合并剩余部分
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return head
```

**哑巴节点写法（无需提前判断头节点）**：
```python
def mergeTwoLists(l1, l2):
    dummy = ListNode()  # 哑巴节点
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next  # 直接返回哑巴节点的 next
```
**为什么更好？**  
- 不需要提前判断 `l1` 和 `l2` 的头节点谁更小。
- `curr` 始终指向新链表的尾部，逻辑更简洁。

---

### **3. 反转链表**
**问题示例**：  
[206. 反转链表](https://leetcode.com/problems/reverse-linked-list/)  
> 反转一个单链表。

**普通写法（需单独处理头节点）**：
```python
def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev  # prev 是新的头节点
```
（注：这个问题哑巴节点不是必须的，但某些变种问题可能需要。）

**哑巴节点在反转部分链表时的优势**：  
比如 [92. 反转链表 II](https://leetcode.com/problems/reverse-linked-list-ii/)（反转链表中指定区间部分）：
```python
def reverseBetween(head, left, right):
    dummy = ListNode(next=head)  # 哑巴节点
    prev = dummy
    # 移动到 left 的前一个节点
    for _ in range(left - 1):
        prev = prev.next
    # 反转 left 到 right 的部分
    curr = prev.next
    for _ in range(right - left):
        next_node = curr.next
        curr.next = next_node.next
        next_node.next = prev.next
        prev.next = next_node
    return dummy.next
```
**为什么需要哑巴节点？**  
- 如果 `left=1`（从头节点开始反转），普通写法需要特殊处理。
- 哑巴节点让 `prev` 始终指向反转区间的前驱，逻辑更统一。

---

### **4. 需要返回新链表的题**
**问题示例**：  
[2. 两数相加](https://leetcode.com/problems/add-two-numbers/)  
> 两个链表表示的数字相加，返回一个新的链表。

**哑巴节点写法**：
```python
def addTwoNumbers(l1, l2):
    dummy = ListNode()  # 哑巴节点
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    return dummy.next
```
**为什么需要哑巴节点？**  
- 新链表的头节点在计算过程中才能确定，哑巴节点可以方便地记录头节点。

---

## **三、不需要哑巴节点的场景**
1. **单纯遍历链表**（如计算长度、查找中间节点）。
2. **递归解法**（递归本身已经隐含了前驱节点的信息）。
3. **头节点不会被修改**（如判断链表是否有环）。

---

## **四、总结：什么时候该用哑巴节点？**
| **场景**                     | **是否需要哑巴节点？** | **示例题目**                                                                 |
|------------------------------|----------------------|-----------------------------------------------------------------------------|
| 可能删除头节点               | ✅ 必须              | [203. 移除链表元素](https://leetcode.com/problems/remove-linked-list-elements/) |
| 合并链表（新链表头不确定）   | ✅ 推荐              | [21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/)   |
| 反转链表（尤其是部分反转）   | ✅ 推荐              | [92. 反转链表 II](https://leetcode.com/problems/reverse-linked-list-ii/)        |
| 需要返回新链表               | ✅ 推荐              | [2. 两数相加](https://leetcode.com/problems/add-two-numbers/)                  |
| 单纯遍历或递归               | ❌ 不需要            | [141. 环形链表](https://leetcode.com/problems/linked-list-cycle/)              |

**核心原则**：  
**如果头节点可能被修改或删除，或者新链表的头节点需要动态确定，就用哑巴节点！**  
它能大幅减少边界条件的判断，让代码更简洁、更健壮。
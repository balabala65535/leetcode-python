`bisect_right` 是 Python 标准库 `bisect` 模块提供的一个**二分查找函数**，用于在**已排序的序列**中查找目标值的**插入位置**（如果有重复元素，则返回最右侧的插入位置）。

---

## 🧠 核心功能
**在有序列表中查找 `target` 应该插入的位置**，保证插入后列表仍然有序：
- 如果 `target` 已存在，返回它**最后一次出现的位置的下一个位置**
- 如果 `target` 不存在，返回它**应该插入的位置**

---

## 📌 基本用法
```python
import bisect

arr = [1, 3, 3, 5, 7]
pos = bisect.bisect_right(arr, target)
```

### 示例分析
| `target` | 返回值 | 解释 |
|----------|--------|------|
| `0`      | `0`    | 插入到最前面 |
| `3`      | `3`    | 最后一个 `3` 之后 |
| `4`      | `3`    | 应插入在 `3` 和 `5` 之间 |
| `8`      | `5`    | 插入到末尾 |

---

## 🔍 对比其他二分函数
| 函数 | 别名 | 目标存在时返回 | 目标不存在时返回 |
|------|------|----------------|------------------|
| `bisect_right` | `bisect` | 最右侧插入位置 | 合适插入位置 |
| `bisect_left`  | -       | 最左侧插入位置 | 合适插入位置 |

---

## 💡 在 `searchMatrix` 中的应用
原代码用 `bisect_right` 是为了：
1. **定位行**：找到第一个行首大于 `target` 的行，然后 `-1` 得到可能包含 `target` 的行
   ```python
   row = bisect.bisect_right([row[0] for row in matrix], target) - 1
   ```
   - 例如 `target=10`，矩阵行首 `[1, 10, 23]`，`bisect_right` 返回 `2`，`-1` 后得到正确行 `1`

2. **保证正确性**：处理重复行首时，`bisect_right` 能定位到重复元素的末尾

---

## 🌰 经典使用场景
1. **插入元素并保持有序**：
   ```python
   arr = [1, 3, 5]
   bisect.insort_right(arr, 4)  # arr → [1, 3, 4, 5]
   ```

2. **范围查询**：统计小于等于 `target` 的元素数量：
   ```python
   count = bisect.bisect_right(arr, target)
   ```

---

## ⚠️ 注意事项
- **列表必须已排序**，否则结果无意义
- 和 `bisect_left` 的选择：
  - 需要**稳定插入到重复元素右侧**时用 `bisect_right`
  - 需要**替换或查找第一个出现位置**时用 `bisect_left`

这个函数是二分查找的高效实现，时间复杂度为 **O(log n)**，非常适合处理有序数据。

from functools import reduce
from typing import *


"""
reduce是Python函数式编程中的一个重要工具，它位于functools模块中。这个函数可以将一个可迭代对象中的元素通过指定的函数进行累积计算。

reduce将以下面的方式工作：
从可迭代对象中取出前两个元素，应用函数计算
将计算结果与下一个元素再次应用函数
重复这个过程直到所有元素处理完毕
如果有初始值，则第一次计算使用初始值和第一个元素
# 使用初始值
result = reduce(lambda x, y: x + y, [1, 2, 3], 10)
print(result)  # 输出: 16 (10+1+2+3)

reduce是函数式编程的有力工具，在适当场景下使用可以使代码更加简洁优雅。


这个现象看起来神奇，但其实完全符合异或运算的数学性质。让我们深入分析为什么 reduce(lambda x, y: x ^ y, [4, 1, 2, 1, 2]) 能正确找出唯一出现的数字4。

异或运算(XOR)的核心性质
自反性：a ^ a = 0

任何数与自己异或结果为0

示例：1 ^ 1 = 0，2 ^ 2 = 0

恒等性：a ^ 0 = a

任何数与0异或保持不变

示例：4 ^ 0 = 4

交换律和结合律：

a ^ b = b ^ a

(a ^ b) ^ c = a ^ (b ^ c)

意味着运算顺序不影响最终结果


这种特性常用于：

找出数组中唯一不重复的数字

检测数据传输中的错误（奇偶校验）

加密算法中的某些操作

面试常见算法题（如LeetCode 136题）

总结
这种方法的精妙之处在于利用了异或运算的特殊数学性质：

成对的数字会自我抵消（变0）

单独的数字会保留下来

运算顺序不影响结果

因此，reduce(lambda x, y: x ^ y, nums) 是一种既优雅又高效（O(n)时间，O(1)空间）的解决方案，特别适合处理这类"找唯一数"的问题。

"""
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)


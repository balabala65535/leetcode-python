

### **回溯算法（Backtracking）知识体系详解**  
回溯算法是一种通过**试错**解决问题的暴力搜索技术，核心思想是**“尝试-回退”**，适用于组合、排列、子集、棋盘类等问题。以下是系统化的整理，涵盖核心思想、框架、剪枝技巧及经典例题。

---

## **一、回溯算法的核心思想**
### **1. 算法特点**
- **暴力搜索**：穷举所有可能的解，通过递归实现。
- **试错与回退**：当当前路径无法得到解时，撤销最后一步选择（回溯），尝试其他路径。
- **适用场景**：问题解空间呈树状结构，且需要遍历所有分支（如组合、排列、分割、子集、棋盘问题）。

### **2. 与DFS的区别**
| **回溯法**               | **DFS**                  |
|--------------------------|--------------------------|
| 显式地“撤销选择”         | 仅遍历，不主动回退       |
| 用于求解所有可行解       | 用于搜索路径或连通性     |

---

## **二、回溯算法的通用框架**
### **1. 递归模板**
```python
def backtrack(路径, 选择列表):
    if 满足终止条件:
        结果.append(路径.copy())  # 注意深拷贝
        return
    
    for 选择 in 选择列表:
        if 选择不合法:  # 剪枝
            continue
        做选择（路径.add(选择)）
        backtrack(路径, 新选择列表)  # 递归
        撤销选择（路径.remove(选择)）  # 回溯
```

### **2. 关键步骤**
1. **选择列表**：当前可选的决策集合（如未使用的数字、可走的格子）。
2. **路径**：已做出的选择（如当前组合、部分解）。
3. **终止条件**：问题解的判定条件（如路径长度达到要求）。
4. **剪枝**：跳过明显无效的选择，提升效率。

---

## **三、回溯算法的四大经典问题**
### **1. 组合问题**
**特点**：从集合中选k个元素，不考虑顺序。  
**例题**：  
- [77. 组合](https://leetcode.com/problems/combinations/)（从1到n中选k个数）  
- [39. 组合总和](https://leetcode.com/problems/combination-sum/)（可重复使用数字）

**代码示例**：
```python
def combine(n, k):
    def backtrack(start, path):
        if len(path) == k:
            res.append(path.copy())
            return
        for i in range(start, n + 1):
            path.append(i)
            backtrack(i + 1, path)  # 避免重复组合
            path.pop()
    res = []
    backtrack(1, [])
    return res
```

### **2. 排列问题**
**特点**：考虑顺序，全排列或部分排列。  
**例题**：  
- [46. 全排列](https://leetcode.com/problems/permutations/)  
- [47. 全排列 II](https://leetcode.com/problems/permutations-ii/)（含重复数字）

**代码示例**：
```python
def permute(nums):
    def backtrack(path):
        if len(path) == len(nums):
            res.append(path.copy())
            return
        for num in nums:
            if num in path:  # 剪枝：已使用过的数字跳过
                continue
            path.append(num)
            backtrack(path)
            path.pop()
    res = []
    backtrack([])
    return res
```

### **3. 子集问题**
**特点**：求集合的所有子集（幂集）。  
**例题**：  
- [78. 子集](https://leetcode.com/problems/subsets/)  
- [90. 子集 II](https://leetcode.com/problems/subsets-ii/)（含重复元素）

**代码示例**：
```python
def subsets(nums):
    def backtrack(start, path):
        res.append(path.copy())  # 所有节点都是解
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    res = []
    backtrack(0, [])
    return res
```

### **4. 棋盘问题**
**特点**：二维空间中的约束满足问题（如N皇后、数独）。  
**例题**：  
- [51. N皇后](https://leetcode.com/problems/n-queens/)  
- [37. 解数独](https://leetcode.com/problems/sudoku-solver/)

**N皇后代码示例**：
```python
def solveNQueens(n):
    def backtrack(row):
        if row == n:
            res.append(["".join(row) for row in board])
            return
        for col in range(n):
            if not is_valid(row, col):
                continue
            board[row][col] = 'Q'
            backtrack(row + 1)
            board[row][col] = '.'
    
    def is_valid(row, col):
        for i in range(row):  # 检查列和对角线
            if board[i][col] == 'Q':
                return False
            if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q':
                return False
            if col + (row - i) < n and board[i][col + (row - i)] == 'Q':
                return False
        return True

    board = [['.'] * n for _ in range(n)]
    res = []
    backtrack(0)
    return res
```

---

## **四、回溯算法的优化技巧**
### **1. 剪枝（Pruning）**
- **可行性剪枝**：提前跳过不满足条件的选择（如组合总和超过目标值）。
- **去重剪枝**：对排序后的数组跳过重复元素（如子集II、排列II）。

**示例**（组合总和II）：
```python
def combinationSum2(candidates, target):
    candidates.sort()  # 排序便于去重
    def backtrack(start, path, remain):
        if remain == 0:
            res.append(path.copy())
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:  # 去重
                continue
            if candidates[i] > remain:  # 剪枝
                break
            path.append(candidates[i])
            backtrack(i + 1, path, remain - candidates[i])
            path.pop()
    res = []
    backtrack(0, [], target)
    return res
```

### **2. 记忆化搜索**
- 适用于含重叠子问题的情况（如分割回文串），用缓存避免重复计算。

### **3. 迭代实现**
- 用栈模拟递归调用，避免递归深度限制（如非递归的全排列）。

---

## **五、高频面试问题**
1. **如何判断问题是否适用回溯法？**  
   - 解空间为树状结构，且需要遍历所有分支。
2. **回溯法的时间复杂度如何分析？**  
   - 通常为指数级（如组合问题O(2^n)），剪枝可降低实际运行时间。
3. **如何避免重复解（如排列II）？**  
   - 排序后跳过相同元素（`if i > 0 and nums[i] == nums[i - 1]: continue`）。

---

## **六、总结与模板**
### **回溯法适用场景**
| **问题类型**       | **例题**                                                                 | **关键点**                     |
|--------------------|-------------------------------------------------------------------------|--------------------------------|
| 组合/子集          | [77. 组合](https://leetcode.com/problems/combinations/)                 | 控制起始位置避免重复           |
| 排列               | [46. 全排列](https://leetcode.com/problems/permutations/)               | 使用`visited`数组标记已选元素  |
| 棋盘问题           | [51. N皇后](https://leetcode.com/problems/n-queens/)                    | 二维空间约束检查               |
| 分割问题           | [131. 分割回文串](https://leetcode.com/problems/palindrome-partitioning/) | 动态规划预处理回文串           |

### **通用模板**
```python
def backtrack(path, choices):
    if meet_condition(path):
        result.add(path)
        return
    for choice in choices:
        if not is_valid(choice):
            continue
        make_choice(path, choice)
        backtrack(path, updated_choices)
        undo_choice(path, choice)
```

掌握回溯算法需要多练习经典题型，重点理解**选择-递归-撤销**的流程和剪枝优化！

你已经刷了100道LeetCode题目，对算法有了初步理解，现在需要将知识体系化。以下是一个结构化的算法知识框架，帮助你建立系统化的认知：

---

### **一、基础数据结构**
1. **数组 & 字符串**
   - 操作：遍历、双指针（对撞指针、快慢指针）、滑动窗口、前缀和
   - 经典问题：二分查找、子串匹配、回文判断

2. **链表**
   - 操作：虚拟头节点、指针操作（反转、环检测）、快慢指针
   - 经典问题：合并链表、倒数第K个节点、LRU缓存

3. **栈 & 队列**
   - 应用场景：括号匹配、单调栈（接雨水）、BFS层序遍历
   - 变体：优先队列（堆）、双端队列

4. **哈希表**
   - 核心：空间换时间、冲突处理
   - 应用：频率统计、快速查找、缓存（HashMap）

---

### **二、高级数据结构**
1. **树与图**
   - **二叉树**：DFS/BFS、前中后序遍历、递归/迭代写法
   - **二叉搜索树**：中序遍历有序性、增删查
   - **堆**：Top K问题、优先队列实现（大顶堆/小顶堆）
   - **图**：邻接表/矩阵表示、DFS/BFS、拓扑排序、最短路径（Dijkstra）

2. **并查集**
   - 核心：路径压缩、按秩合并
   - 应用：连通性问题（朋友圈、岛屿数量）

3. **字典树（Trie）**
   - 应用：前缀匹配、单词搜索

---

### **三、算法思想**
1. **递归 & 分治**
   - 关键：终止条件、递归公式（如斐波那契、归并排序）
   - 分治模板：分解 → 解决 → 合并（如快速排序）

2. **动态规划（DP）**
   - **核心**：状态定义、转移方程、初始化、优化（空间压缩）
   - **类型**：
     - 线性DP（打家劫舍、股票问题）
     - 背包问题（01背包、完全背包）
     - 区间DP（最长回文子串）
     - 树形DP（二叉树偷窃问题）

3. **贪心算法**
   - 特点：局部最优→全局最优（需证明正确性）
   - 例子：区间调度、跳跃游戏

4. **回溯法**
   - 模板：选择 → 递归 → 撤销选择（全排列、N皇后）
   - 剪枝优化：避免无效搜索

5. **搜索算法**
   - **BFS**：层序遍历、最短路径（无权图）
   - **DFS**：回溯、连通性问题
   - **A***：启发式搜索（带权图）

---

### **四、经典问题分类**
1. **排序算法**
   - 比较排序：快排（分治）、归并（分治）、堆排序
   - 非比较排序：计数排序、桶排序

2. **数学问题**
   - 位运算（异或、位掩码）、素数判定、模运算

3. **设计类问题**
   - 数据结构设计（LRU、LFU）、系统设计（短网址）

---

### **五、优化技巧**
1. **时间/空间权衡**
   - 预计算（前缀和、哈希预处理）
   - 空间压缩（DP降维）

2. **边界条件**
   - 数组越界、空输入、整数溢出

3. **代码模板化**
   - 如二分查找的`left <= right` vs `left < right`

---

### **六、下一步建议**
1. **按标签复习**：将做过的题目按上述分类整理，总结共性。
2. **专项突破**：针对薄弱点（如DP、图论）集中练习。
3. **模拟面试**：限时训练（如2题/小时），培养手感和速度。
4. **复杂度分析**：每题完成后明确时间/空间复杂度。

---

### **示例体系化整理（以DP为例）**
| 问题类型       | 经典题目               | 状态定义                  | 转移方程                     | 优化技巧         |
|----------------|------------------------|---------------------------|------------------------------|------------------|
| 线性DP         | 爬楼梯（LeetCode 70）  | `dp[i]`表示到第i阶的方法数 | `dp[i] = dp[i-1] + dp[i-2]`  | 滚动数组         |
| 背包问题       | 零钱兑换（LeetCode 322） | `dp[i]`表示金额i的最小硬币数 | `dp[i] = min(dp[i], dp[i-coin]+1)` | 遍历顺序优化     |
| 区间DP         | 最长回文子串（LeetCode 5） | `dp[i][j]`表示s[i..j]是否回文 | `dp[i][j] = (s[i]==s[j]) && dp[i+1][j-1]` | 对角线填充       |

通过这样的整理，你可以将零散的知识点连接成网络，形成条件反射式的解题思维。如果需要针对某一部分深入讨论，可以随时告诉我！
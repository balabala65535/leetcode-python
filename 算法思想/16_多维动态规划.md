
### **多维动态规划（Multi-Dimensional DP）知识体系详解**

多维动态规划是动态规划的进阶形式，通过**多维状态定义**解决复杂问题（如字符串匹配、矩阵路径、带约束的优化等）。以下是系统化的知识整理，涵盖核心思想、状态设计、经典题型及优化技巧。

---

## **一、多维DP的核心思想**
### **1. 适用场景**
- **问题具有多个维度**：如两个字符串的比较、二维矩阵路径、带额外约束（如次数限制）的优化问题。
- **状态转移依赖多个变量**：当前决策受多个前驱状态影响。

### **2. 状态设计要点**
- **状态维度**：通常由问题中的变量数量决定（如 `dp[i][j]` 表示处理到字符串A的第i位和字符串B的第j位）。
- **状态含义**：明确 `dp[i][j]` 代表的解（如最小操作数、最大收益、是否可达等）。
- **初始化与边界**：注意 `i=0` 或 `j=0` 时的初始状态。

### **3. 与一维DP的区别**
| **一维DP**               | **多维DP**                  |
|--------------------------|----------------------------|
| 状态仅依赖前一两个状态   | 状态依赖多个维度           |
| 如斐波那契、爬楼梯       | 如编辑距离、背包问题       |

---

## **二、多维DP的四大经典问题**
### **1. 字符串匹配与编辑距离**
**问题类型**：两个字符串的匹配、转换或对齐问题。  
**例题**：  
- [72. 编辑距离](https://leetcode.com/problems/edit-distance/)  
- [1143. 最长公共子序列（LCS）](https://leetcode.com/problems/longest-common-subsequence/)  

#### **编辑距离模板**
```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    # 初始化：空串到非空串的编辑次数
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    # 状态转移
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],    # 删除word1[i]
                    dp[i][j-1],    # 插入word2[j]
                    dp[i-1][j-1]   # 替换
                )
    return dp[m][n]
```
**关键点**：  
- `dp[i][j]` 表示 `word1[:i]` 和 `word2[:j]` 的最小编辑次数。
- 状态转移分字符相等和不等两种情况。

### **2. 矩阵路径问题**
**问题类型**：在二维矩阵中寻找最优路径（如最小路径和、最大收益）。  
**例题**：  
- [64. 最小路径和](https://leetcode.com/problems/minimum-path-sum/)  
- [62. 不同路径](https://leetcode.com/problems/unique-paths/)  

#### **最小路径和模板**
```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    # 初始化第一行和第一列
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    # 状态转移
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    return dp[m-1][n-1]
```
**关键点**：  
- `dp[i][j]` 表示从 `(0,0)` 到 `(i,j)` 的最小路径和。
- 只能向右或向下移动，依赖上方和左方的状态。

### **3. 背包问题（二维约束）**
**问题类型**：在容量和重量等双重约束下的最优选择。  
**例题**：  
- [474. 一和零](https://leetcode.com/problems/ones-and-zeroes/)（二维背包）  
- [494. 目标和](https://leetcode.com/problems/target-sum/)（转化为背包问题）  

#### **二维背包模板（一和零）**
```python
def findMaxForm(strs, m, n):
    # dp[i][j]：最多使用i个0和j个1时的最大子集大小
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for s in strs:
        zeros = s.count('0')
        ones = len(s) - zeros
        for i in range(m, zeros - 1, -1):      # 倒序遍历防重复
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)
    return dp[m][n]
```
**关键点**：  
- 状态 `dp[i][j]` 受两个约束（0的数量和1的数量）。
- 倒序遍历避免重复计算（类似0-1背包）。

### **4. 状态机DP（带额外状态）**
**问题类型**：问题需要记录额外状态（如交易次数、持有股票与否）。  
**例题**：  
- [123. 买卖股票的最佳时机 III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)  
- [188. 买卖股票的最佳时机 IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)  

#### **股票问题模板（限制k次交易）**
```python
def maxProfit(k, prices):
    if not prices:
        return 0
    n = len(prices)
    if k >= n // 2:  # 转化为无限次交易
        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, n))
    # dp[i][j][0]：第i天，交易j次，不持有股票
    # dp[i][j][1]：第i天，交易j次，持有股票
    dp = [[[-float('inf')] * 2 for _ in range(k + 1)] for _ in range(n)]
    dp[0][0][0] = 0
    dp[0][0][1] = -prices[0]
    for i in range(1, n):
        for j in range(k + 1):
            dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
            if j > 0:
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])
            else:
                dp[i][j][1] = dp[i-1][j][1]
    return max(dp[n-1][j][0] for j in range(k + 1))
```
**关键点**：  
- 状态增加交易次数和持股状态两个维度。
- 初始化需注意 `j=0` 时的边界条件。

---

## **三、多维DP的优化技巧**
### **1. 空间压缩**
- **滚动数组**：仅保留必要的前一状态（如 `dp[i][j]` 只依赖 `dp[i-1][j]` 和 `dp[i][j-1]`，可压缩为一维数组）。
- **示例（最小路径和的空间优化）**：
  ```python
  def minPathSum(grid):
      m, n = len(grid), len(grid[0])
      dp = [0] * n
      dp[0] = grid[0][0]
      for j in range(1, n):
          dp[j] = dp[j-1] + grid[0][j]
      for i in range(1, m):
          dp[0] += grid[i][0]
          for j in range(1, n):
              dp[j] = min(dp[j], dp[j-1]) + grid[i][j]
      return dp[-1]
  ```

### **2. 降维打击**
- **问题转化**：将多维问题转化为低维问题（如将字符串匹配转化为LCS）。
- **示例（目标和问题转化为背包问题）**：
  ```python
  def findTargetSumWays(nums, target):
      total = sum(nums)
      if (total + target) % 2 != 0 or total < abs(target):
          return 0
      pos = (total + target) // 2
      dp = [0] * (pos + 1)
      dp[0] = 1
      for num in nums:
          for j in range(pos, num - 1, -1):
              dp[j] += dp[j - num]
      return dp[pos]
  ```

### **3. 记忆化搜索**
- **递归+缓存**：适用于状态转移复杂或维度不固定的问题。
- **示例（最长递增路径）**：
  ```python
  def longestIncreasingPath(matrix):
      if not matrix: return 0
      m, n = len(matrix), len(matrix[0])
      memo = [[0] * n for _ in range(m)]
      def dfs(i, j):
          if memo[i][j] != 0:
              return memo[i][j]
          directions = [(0,1),(1,0),(0,-1),(-1,0)]
          max_len = 1
          for dx, dy in directions:
              x, y = i + dx, j + dy
              if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:
                  max_len = max(max_len, 1 + dfs(x, y))
          memo[i][j] = max_len
          return max_len
      return max(dfs(i, j) for i in range(m) for j in range(n))
  ```

---

## **四、高频面试问题**
1. **如何设计多维DP的状态？**  
   - 根据问题变量数量确定维度，明确 `dp[i][j]` 的具体含义。
2. **何时用多维DP替代回溯？**  
   - 当问题存在重叠子问题且无后效性时，DP可避免重复计算。
3. **如何优化多维DP的空间？**  
   - 使用滚动数组或状态压缩（如位运算）。
4. **多维DP的初始化技巧？**  
   - 单独处理 `i=0` 或 `j=0` 的边界情况，避免越界。

---

## **五、总结与模板**
### **多维DP的解题步骤**
1. **定义状态**：明确 `dp[i][j][...]` 的含义。
2. **初始化**：处理边界条件（如空串、第一行/列）。
3. **状态转移**：根据问题逻辑写出递推式。
4. **优化空间**：尝试压缩状态维度。

### **经典问题分类**
| **问题类型**       | **例题**                                                                 | **状态设计技巧**               |
|--------------------|-------------------------------------------------------------------------|--------------------------------|
| 字符串匹配         | [72. 编辑距离](https://leetcode.com/problems/edit-distance/)            | `dp[i][j]` 表示A[:i]和B[:j]的编辑次数 |
| 矩阵路径           | [64. 最小路径和](https://leetcode.com/problems/minimum-path-sum/)       | `dp[i][j]` 表示到(i,j)的最小和 |
| 二维约束问题       | [474. 一和零](https://leetcode.com/problems/ones-and-zeroes/)           | `dp[i][j]` 受0和1的数量限制    |
| 状态机DP           | [188. 买卖股票IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) | 增加交易次数和持股状态维度     |

掌握多维DP的关键在于**多练习状态设计**和**熟练空间优化技巧**，通过经典题型训练可快速提升解题能力！

### **堆（Heap）知识体系详解**

堆是一种特殊的**完全二叉树**，具有高效的极值访问和动态更新能力，是优先级队列的理想实现方式。以下是堆的系统化整理，涵盖核心概念、操作实现、应用场景及经典问题。

---

## **一、堆的基本概念**
### **1. 堆的性质**
- **完全二叉树结构**：除最后一层外，其他层节点必须填满，且最后一层靠左排列。
- **堆序性**：
  - **最小堆**：父节点值 ≤ 子节点值（根节点为最小值）。
  - **最大堆**：父节点值 ≥ 子节点值（根节点为最大值）。
- **操作时间复杂度**：
  - 插入（`push`）：O(log n)
  - 删除极值（`pop`）：O(log n)
  - 获取极值（`peek`）：O(1)

### **2. 堆的存储**
堆通常用**数组**实现，利用下标关系表示父子节点：
- 父节点 `i` 的左子节点：`2i + 1`
- 父节点 `i` 的右子节点：`2i + 2`
- 子节点 `i` 的父节点：`⌊(i - 1)/2⌋`

**示例**：  
最大堆 `[9, 5, 8, 1, 3]` 的数组和树形表示：
```
      9
    /   \
   5     8
  / \
1    3
```

---

## **二、堆的核心操作**
### **1. 上浮（Heapify Up）**
- **场景**：插入新元素后，从底部向上调整堆。
- **步骤**：
  1. 将新元素放入数组末尾。
  2. 比较其与父节点的值，若违反堆序性则交换。
  3. 重复步骤2直至满足堆序性。

**代码实现**（最小堆）：
```python
def heapify_up(heap, index):
    parent = (index - 1) // 2
    while index > 0 and heap[index] < heap[parent]:
        heap[index], heap[parent] = heap[parent], heap[index]
        index = parent
        parent = (index - 1) // 2
```

### **2. 下沉（Heapify Down）**
- **场景**：删除堆顶后，从顶部向下调整堆。
- **步骤**：
  1. 将堆顶与末尾元素交换，删除末尾。
  2. 比较新堆顶与其子节点的值，若违反堆序性则与更小的子节点交换（最小堆）。
  3. 重复步骤2直至满足堆序性。

**代码实现**（最小堆）：
```python
def heapify_down(heap, index):
    n = len(heap)
    while True:
        left = 2 * index + 1
        right = 2 * index + 2
        smallest = index
        if left < n and heap[left] < heap[smallest]:
            smallest = left
        if right < n and heap[right] < heap[smallest]:
            smallest = right
        if smallest == index:
            break
        heap[index], heap[smallest] = heap[smallest], heap[index]
        index = smallest
```

### **3. 建堆（Heapify）**
- **场景**：将无序数组转换为堆。
- **方法**：从最后一个非叶子节点开始，依次执行下沉操作。
- **时间复杂度**：O(n)（非直觉的数学结论）。

**代码实现**：
```python
def build_heap(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify_down(arr, i)
```

---

## **三、堆的应用场景**
### **1. 优先级队列**
- **典型问题**：动态获取当前极值（如任务调度、Dijkstra算法）。
- **Python实现**：`heapq` 模块（仅支持最小堆，最大堆需取负数存储）。

**示例**（合并K个有序链表）：
```python
import heapq

def mergeKLists(lists):
    min_heap = []
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(min_heap, (node.val, i))
    dummy = curr = ListNode()
    while min_heap:
        val, i = heapq.heappop(min_heap)
        curr.next = ListNode(val)
        curr = curr.next
        if lists[i].next:
            lists[i] = lists[i].next
            heapq.heappush(min_heap, (lists[i].val, i))
    return dummy.next
```

### **2. Top K 问题**
- **最小堆**：维护大小为K的堆，保留最大的K个元素。
- **最大堆**：维护大小为K的堆，保留最小的K个元素。

**示例**（前K个高频元素）：
```python
import heapq

def topKFrequent(nums, k):
    freq = collections.Counter(nums)
    min_heap = []
    for num, count in freq.items():
        heapq.heappush(min_heap, (count, num))
        if len(min_heap) > k:
            heapq.heappop(min_heap)
    return [num for count, num in min_heap]
```

### **3. 堆排序**
- **步骤**：
  1. 建堆（O(n)）。
  2. 依次取出堆顶元素（O(n log n)）。

**代码实现**：
```python
def heap_sort(arr):
    build_heap(arr)
    sorted_arr = []
    while arr:
        arr[0], arr[-1] = arr[-1], arr[0]
        sorted_arr.append(arr.pop())
        heapify_down(arr, 0)
    return sorted_arr
```

---

## **四、堆的进阶技巧**
### **1. 双堆维护中位数**
- **方法**：
  - 最大堆存储较小的一半。
  - 最小堆存储较大的一半。
- **平衡条件**：两堆大小差 ≤ 1。

**示例**（数据流的中位数）：
```python
import heapq

class MedianFinder:
    def __init__(self):
        self.max_heap = []  # 存储较小的一半（Python需用负数模拟最大堆）
        self.min_heap = []  # 存储较大的一半

    def addNum(self, num):
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
        else:
            heapq.heappush(self.min_heap, num)
        # 平衡两堆大小
        if len(self.max_heap) > len(self.min_heap) + 1:
            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        elif len(self.min_heap) > len(self.max_heap):
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))

    def findMedian(self):
        if len(self.max_heap) == len(self.min_heap):
            return (-self.max_heap[0] + self.min_heap[0]) / 2
        else:
            return -self.max_heap[0]
```

### **2. 延迟删除优化**
- **场景**：堆中元素需动态删除，但直接删除成本高。
- **方法**：用哈希表记录待删除元素，在堆顶遇到时再删除。

---

## **五、高频面试问题**
1. **堆和优先队列的区别？**  
   - 堆是数据结构，优先队列是抽象接口（堆是其常见实现）。
2. **如何实现最大堆？**  
   - Python的`heapq`仅支持最小堆，可存储负数模拟最大堆。
3. **建堆的时间复杂度为什么是O(n)？**  
   - 数学推导：各层节点下沉操作次数总和收敛于n。

---

## **六、总结与模板**
### **堆的适用场景**
| **问题类型**       | **例题**                                                                 | **堆的类型**          |
|--------------------|-------------------------------------------------------------------------|-----------------------|
| 动态极值查询       | [295. 数据流的中位数](https://leetcode.com/problems/find-median-from-data-stream/) | 双堆（最大堆+最小堆） |
| Top K 问题         | [347. 前K个高频元素](https://leetcode.com/problems/top-k-frequent-elements/)     | 最小堆                |
| 合并有序序列       | [23. 合并K个升序链表](https://leetcode.com/problems/merge-k-sorted-lists/)       | 最小堆                |

### **Python堆操作模板**
```python
import heapq

# 最小堆
heap = []
heapq.heappush(heap, item)      # 插入
top = heapq.heappop(heap)       # 弹出最小值
smallest = heap[0]              # 查看最小值（不弹出）

# 最大堆（存储负数）
max_heap = []
heapq.heappush(max_heap, -item)
max_item = -heapq.heappop(max_heap)
```

掌握堆的核心在于理解其**完全二叉树结构**和**堆序性维护**，通过经典问题练习可快速提升应用能力！
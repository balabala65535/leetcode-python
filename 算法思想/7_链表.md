### **链表（Linked List）算法知识体系详解**  
链表是线性表的一种，通过指针链接节点，分为**单向链表、双向链表、循环链表**等。以下是链表问题的系统化整理，涵盖核心操作、解题方法、经典例题及优化技巧。

---

## **一、链表基础**
### **1. 链表类型**
| **类型**         | **特点**                          | **应用场景**               |
|------------------|-----------------------------------|---------------------------|
| 单向链表         | 每个节点包含`val`和`next`指针      | 一般链表操作              |
| 双向链表         | 节点含`prev`和`next`指针           | LRU缓存、频繁双向遍历     |
| 循环链表         | 尾节点指向头节点                   | 环形缓冲区、约瑟夫问题    |

### **2. 核心操作**
| **操作**       | **时间复杂度** | **关键点**                     |
|----------------|----------------|--------------------------------|
| 遍历           | O(n)           | 注意边界条件（如`head is None`）|
| 插入/删除      | O(1)（已知前驱节点） | 需处理头节点特殊情况      |
| 查找           | O(n)           | 无法随机访问                  |

---

## **二、链表的四大解题方法**
### **1. 虚拟头节点（Dummy Node）**
**作用**：简化头节点删除或插入操作。  
**例题**：  
- [203. 移除链表元素](https://leetcode.com/problems/remove-linked-list-elements/)  
- [21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/)  

**代码模板**：
```python
def removeElements(head, val):
    dummy = ListNode(next=head)  # 虚拟头节点
    curr = dummy
    while curr.next:
        if curr.next.val == val:
            curr.next = curr.next.next
        else:
            curr = curr.next
    return dummy.next
```

### **2. 快慢指针**
**应用场景**：环形链表检测、找中点、倒数第K个节点。  
**例题**：  
- [141. 环形链表](https://leetcode.com/problems/linked-list-cycle/)  
- [876. 链表的中间结点](https://leetcode.com/problems/middle-of-the-linked-list/)  

**找中点代码**：
```python
def middleNode(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```

### **3. 反转链表**
**核心思想**：修改指针方向（迭代或递归）。  
**例题**：  
- [206. 反转链表](https://leetcode.com/problems/reverse-linked-list/)  
- [92. 反转链表 II](https://leetcode.com/problems/reverse-linked-list-ii/)  

**迭代反转代码**：
```python
def reverseList(head):
    prev, curr = None, head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

### **4. 递归分治**
**适用场景**：链表合并、分解问题（如回文链表判断）。  
**例题**：  
- [234. 回文链表](https://leetcode.com/problems/palindrome-linked-list/)  
- [148. 排序链表](https://leetcode.com/problems/sort-list/)  

**合并两个有序链表（递归）**：
```python
def mergeTwoLists(l1, l2):
    if not l1: return l2
    if not l2: return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

---

## **三、高频问题分类**
### **1. 环形链表问题**
| 题目                                                                 | 解法思路                                                                 |
|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| [141. 环形链表](https://leetcode.com/problems/linked-list-cycle/)    | 快慢指针：快指针每次走两步，慢指针走一步，相遇则有环。                   |
| [142. 环形链表 II](https://leetcode.com/problems/linked-list-cycle-ii/) | 快慢指针相遇后，从头节点和相遇点同时出发，再次相遇即为环入口。           |

### **2. 链表删除与修改**
| 题目                                                                 | 解法思路                                                                 |
|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| [19. 删除链表的倒数第N个节点](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | 快指针先走N步，慢指针同步移动，快指针到末尾时删除慢指针的下一个节点。    |
| [82. 删除排序链表中的重复元素 II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/) | 虚拟头节点 + 双指针，跳过所有重复节点。                                  |

### **3. 链表合并与拆分**
| 题目                                                                 | 解法思路                                                                 |
|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| [21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/) | 迭代或递归比较节点值，按序拼接。                                         |
| [86. 分隔链表](https://leetcode.com/problems/partition-list/)        | 创建两个子链表，分别存储小于和大于等于目标值的节点，最后拼接。           |

### **4. 复杂链表操作**
| 题目                                                                 | 解法思路                                                                 |
|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| [138. 复制带随机指针的链表](https://leetcode.com/problems/copy-list-with-random-pointer/) | 哈希表存储原节点与复制节点的映射，再处理`next`和`random`指针。            |
| [25. K个一组翻转链表](https://leetcode.com/problems/reverse-nodes-in-k-group/) | 分段反转：统计每组长度，反转后拼接。                                     |

---

## **四、优化技巧**
1. **边界处理**：  
   - 链表为空、只有一个节点、头节点需删除时特殊处理。  
2. **空间优化**：  
   - 多数问题可通过指针操作实现O(1)空间（如反转链表）。  
3. **递归转迭代**：  
   - 避免栈溢出（如递归反转链表改为迭代）。  

---

## **五、面试高频考点**
1. **如何判断链表是否有环？如何找环入口？**  
   - 快慢指针相遇后，数学推导证明环入口位置。  
2. **如何优化链表的查找操作？**  
   - 无法直接优化为O(1)，但可结合哈希表（如LRU缓存）。  
3. **链表和数组的取舍？**  
   - 频繁插入/删除 → 链表；频繁随机访问 → 数组。  

---

掌握这些方法后，链表问题可系统化解决。如需更深入的题目解析或代码细节，欢迎继续提问！


在 Python 中，**链表默认是不可直接迭代的**（即不能直接用 `for` 循环遍历），因为链表节点之间通过指针（`next`）连接，不像数组或列表那样在内存中连续存储。但可以通过以下方法实现链表的迭代：

---

### **1. 手动实现链表的迭代**
如果链表是自定义的 `ListNode` 类（如 LeetCode 中的定义），需要手动实现迭代器协议（`__iter__` 方法）才能支持 `for` 循环。

#### **示例：让链表支持 `for` 循环**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    
    # 实现迭代器协议
    def __iter__(self):
        current = self
        while current:
            yield current.val  # 每次迭代返回当前节点的值
            current = current.next

# 创建链表: 1 -> 2 -> 3
head = ListNode(1, ListNode(2, ListNode(3)))

# 用 for 循环遍历
for val in head:
    print(val)  # 输出: 1 2 3
```

---

### **2. 直接遍历链表（非 `for` 循环）**
如果链表未实现迭代器，通常用 `while` 循环遍历：
```python
current = head
while current:
    print(current.val)
    current = current.next
```

---

### **3. 为什么链表默认不可迭代？**
- **Python 的 `list` 是内置的可迭代对象**，因为它实现了 `__iter__` 方法。
- **自定义链表**只是一个由节点对象组成的链式结构，需要手动添加迭代逻辑。

---

### **4. 特殊情况：LeetCode 的链表**
在 LeetCode 或算法题中，链表通常以 `ListNode` 类给出，**默认不支持 `for` 循环**，必须用 `while` 遍历：
```python
def print_linked_list(head):
    current = head
    while current:
        print(current.val)
        current = current.next
```

---

### **总结**
| **场景**               | **是否可用 `for` 循环** | **解决方法**                     |
|------------------------|------------------------|----------------------------------|
| 自定义链表（实现 `__iter__`） | ✅ 可以                 | 实现 `__iter__` 方法             |
| 普通链表（如 LeetCode）      | ❌ 不可以               | 用 `while` 循环 + `next` 指针遍历 |

如果需要让链表支持 `for` 循环，建议按方法 1 实现迭代器协议；否则直接用 `while` 遍历即可。

在 Python 中，**默认情况下 `ListNode` 也不能直接添加到集合（`set`）中**，因为集合（`set`）和字典（`dict`）的键一样，要求元素必须是 **可哈希（hashable）** 的，而 `ListNode` 作为可变对象，默认是不可哈希的。

### **1. 直接尝试添加 `ListNode` 到集合会报错**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

node1 = ListNode(1)
node2 = ListNode(2)

s = set()
s.add(node1)  # ❌ TypeError: unhashable type: 'ListNode'
```

### **2. 为什么有时候“看似”可以添加？**
如果发现 `ListNode` 能被添加到集合里，可能是以下情况：
1. **自定义了 `__hash__` 和 `__eq__` 方法**  
   如果你（或某些代码库）在 `ListNode` 类中实现了 `__hash__` 和 `__eq__`，使其变为可哈希对象，那么它就可以被添加到集合中。  
   **示例**：
   ```python
   class ListNode:
       def __init__(self, val=0, next=None):
           self.val = val  # 假设 val 是不可变的（如 int、str）
           self.next = next

       def __hash__(self):
           return hash(self.val)  # 基于 val 计算哈希值

       def __eq__(self, other):
           return isinstance(other, ListNode) and self.val == other.val

   node1 = ListNode(1)
   node2 = ListNode(1)
   s = set()
   s.add(node1)
   s.add(node2)
   print(s)  # 输出: {<__main__.ListNode object at 0x...>}（只有 1 个元素，因为 val 相同）
   ```

2. **使用了 `id(node)` 作为替代**  
   某些情况下，可能会用节点的内存地址（`id(node)`）作为唯一标识，但这不是直接存储 `ListNode` 本身：
   ```python
   s = set()
   s.add(id(node1))  # ✅ 可行，因为 id(node) 是整数（可哈希）
   ```

3. **某些特殊库的实现**  
   部分第三方库（如 `networkx` 处理图结构时）可能对节点做了特殊封装，使其可哈希。

---

### **3. 默认情况下为什么 `ListNode` 不可哈希？**
- Python 要求可哈希对象必须满足：
  1. **哈希值在其生命周期内不变**（如果 `ListNode.val` 可变，则违反此条件）。
  2. **支持 `__eq__()` 方法**用于比较。
- `ListNode` 是可变对象（可以修改 `val` 和 `next`），因此默认不可哈希。

---

### **4. 如何安全地使用 `ListNode` 在集合中？**
#### **方法 1：重写 `__hash__` 和 `__eq__`（需确保 `val` 不可变）**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val  # val 必须是不可变类型（如 int、str、tuple）
        self.next = next

    def __hash__(self):
        return hash(self.val)

    def __eq__(self, other):
        return isinstance(other, ListNode) and self.val == other.val

node1 = ListNode(1)
node2 = ListNode(1)
s = {node1, node2}  # 只有 1 个元素（因为 val 相同）
```

#### **方法 2：使用 `id(node)` 或唯一标识符**
```python
node1 = ListNode(1)
node2 = ListNode(2)
s = {id(node1), id(node2)}  # 存储内存地址（但需注意节点生命周期）
```

#### **方法 3：转换为元组（如果结构简单）**
```python
node1 = ListNode(1)
node2 = ListNode(2)
s = {(node1.val, id(node1)), (node2.val, id(node2))}  # 使用 (val, id) 作为唯一键
```

---

### **5. 总结**
| **场景**                     | **是否可添加到集合** | **条件**                                  |
|------------------------------|----------------------|------------------------------------------|
| 默认 `ListNode`              | ❌ 不可              | 因为可变，未实现 `__hash__` 和 `__eq__`  |
| 自定义 `__hash__` 和 `__eq__` | ✅ 可以              | 需确保依赖的属性（如 `val`）不可变       |
| 使用 `id(node)`              | ✅ 可以              | 但实际存储的是整数，不是节点对象本身     |

**最佳实践**：  
- 如果需要用 `ListNode` 作为集合元素，优先重写 `__hash__` 和 `__eq__`，并确保依赖的属性不可变。  
- 如果节点可能被修改，避免直接存储到集合中，改用其他唯一标识（如 `id` 或 `(val, id)`）。


### **滑动窗口算法体系详解**  
滑动窗口是**双指针的高级应用**，专门解决数组/字符串中的**子串、子数组问题**。核心思想是通过维护一个动态窗口，用线性时间（O(n)）解决暴力枚举（O(n²)）的问题。以下是系统化整理：

---

## **一、滑动窗口的核心思想**
### **1. 适用场景**
- **问题特征**：
  - 要求计算**连续子串/子数组**的相关结果（如最长、最短、满足某条件）。
  - 通常伴随**“最小覆盖”**、**“无重复字符”**、**“满足条件的最大/最小长度”**等关键词。
- **经典问题**：
  - 无重复字符的最长子串（LeetCode 3）
  - 最小覆盖子串（LeetCode 76）
  - 长度最小的子数组（LeetCode 209）

### **2. 算法框架**
```python
def sliding_window(s, t):
    left = 0
    window = {}  # 记录窗口内字符的统计信息
    res = ""     # 存储结果
    
    for right in range(len(s)):
        # 1. 右指针扩张窗口
        window[s[right]] = window.get(s[right], 0) + 1
        
        # 2. 检查是否满足条件
        while 满足收缩条件:
            # 3. 更新结果（如果需要）
            if 当前窗口更优:
                res = s[left:right+1]
            
            # 4. 左指针收缩窗口
            window[s[left]] -= 1
            if window[s[left]] == 0:
                del window[s[left]]
            left += 1
    
    return res
```

---

## **二、滑动窗口的两种类型**
### **1. 固定长度窗口**
- **特点**：窗口大小固定（如求长度为k的子数组的最大和）。
- **模板**：
  ```python
  window_sum = sum(arr[:k])
  max_sum = window_sum
  
  for i in range(k, len(arr)):
      window_sum += arr[i] - arr[i - k]  # 滑动窗口
      max_sum = max(max_sum, window_sum)
  ```
- **例题**：
  - [643. 子数组最大平均数 I](https://leetcode.com/problems/maximum-average-subarray-i/)

### **2. 可变长度窗口**
- **特点**：窗口大小动态变化（如找最短/最长满足条件的子串）。
- **关键点**：
  - **扩张**：右指针移动，直到满足条件。
  - **收缩**：左指针移动，优化窗口。
- **例题**：
  - [3. 无重复字符的最长子串](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
  - [76. 最小覆盖子串](https://leetcode.com/problems/minimum-window-substring/)

---

## **三、经典问题解析**
### **1. 无重复字符的最长子串（LeetCode 3）**
- **问题**：找不含重复字符的最长子串。
- **解法**：
  - 用哈希表记录字符最后一次出现的位置。
  - 当字符重复时，移动`left`到`max(left, 上次出现位置 + 1)`。
- **代码**：
  ```python
  def lengthOfLongestSubstring(s):
      left = 0
      max_len = 0
      last_pos = {}  # 存储字符最后一次出现的索引
      
      for right in range(len(s)):
          if s[right] in last_pos:
              left = max(left, last_pos[s[right]] + 1)
          last_pos[s[right]] = right
          max_len = max(max_len, right - left + 1)
      
      return max_len
  ```

### **2. 最小覆盖子串（LeetCode 76）**
- **问题**：在`s`中找到涵盖`t`所有字符的最短子串。
- **解法**：
  - 用哈希表`need`统计`t`的字符需求。
  - 扩张窗口直到满足条件，然后收缩优化。
- **代码**：
  ```python
  def minWindow(s, t):
      from collections import defaultdict
      need = defaultdict(int)
      for c in t:
          need[c] += 1
      
      left, valid = 0, 0
      min_len = float('inf')
      res = ""
      
      for right in range(len(s)):
          if s[right] in need:
              need[s[right]] -= 1
              if need[s[right]] == 0:
                  valid += 1
          
          while valid == len(need):
              if right - left + 1 < min_len:
                  min_len = right - left + 1
                  res = s[left:right+1]
              
              if s[left] in need:
                  if need[s[left]] == 0:
                      valid -= 1
                  need[s[left]] += 1
              left += 1
      
      return res
  ```

---

## **四、滑动窗口的优化技巧**
### **1. 哈希表优化**
- 用`defaultdict`或`数组`代替普通哈希表，减少边界判断。
- **示例**：字符频率统计可用`count = [0] * 128`（ASCII码范围）。

### **2. 收缩条件的简化**
- 某些问题中，`while`可改为`if`（如固定窗口问题）。

### **3. 变量复用**
- 用`valid`变量统计满足条件的字符数，避免频繁遍历哈希表。

---

## **五、滑动窗口 vs 其他算法**
| **场景**               | **滑动窗口**           | **替代算法**          |
|------------------------|------------------------|-----------------------|
| 连续子串问题           | ✅ O(n) 最优解          | 暴力枚举（O(n²)）     |
| 需要全局最优解         | ❌ 可能不适用           | 动态规划（如最长递增子序列） |
| 无序数组中的子数组和   | ❌ 需配合前缀和         | 前缀和 + 哈希表       |

---

## **六、高频面试考点**
1. **如何证明滑动窗口的正确性？**  
   - 通过**单调性**证明：窗口扩张/收缩不会错过最优解。
2. **滑动窗口和双指针的区别？**  
   - 滑动窗口是双指针的特定应用，专注于**连续区间问题**。
3. **如果字符串包含Unicode字符怎么办？**  
   - 用`defaultdict`或扩展数组（如`count = [0] * 65536`）。

---

通过掌握滑动窗口的**核心框架**和**问题分类**，可以高效解决90%的子串/子数组问题。如果需要更具体的题目解析或代码优化，欢迎继续提问！
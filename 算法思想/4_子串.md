### **子串（Substring）算法知识体系详解**  
子串问题是字符串处理中的核心题型，常涉及**滑动窗口、动态规划、哈希表**等技巧。以下是系统化的整理，涵盖**定义、解题方法、经典例题及优化技巧**。

---

## **一、子串 vs 子序列**
| **类型**  | **定义**                          | **特点**               | **例题**                          |
|-----------|-----------------------------------|------------------------|-----------------------------------|
| **子串**  | 字符串中**连续**的字符序列        | 必须保持顺序和连续性   | "abc"的子串："a", "ab", "abc", "b" |
| **子序列**| 字符串中**不连续**但顺序一致的序列 | 只需保持顺序，可不连续 | "abc"的子序列："ac", "bc", "a"    |

---

## **二、子串问题的五大解法**
### **1. 滑动窗口（80%子串问题首选）**
- **适用场景**：  
  - 找**最长/最短**满足条件的子串（如无重复字符、最小覆盖子串）。  
  - 时间复杂度：**O(n)**。  
- **核心思想**：  
  - **扩张**右指针直到满足条件，**收缩**左指针优化解。  
- **例题**：  
  - [3. 无重复字符的最长子串](https://leetcode.com/problems/longest-substring-without-repeating-characters/)  
  - [76. 最小覆盖子串](https://leetcode.com/problems/minimum-window-substring/)  

#### **模板代码（Python）**
```python
def sliding_window(s):
    left = 0
    window = {}  # 记录窗口内字符状态
    max_len = 0
    
    for right in range(len(s)):
        # 1. 右扩窗口
        window[s[right]] = window.get(s[right], 0) + 1
        
        # 2. 左缩条件
        while 窗口不满足条件:
            window[s[left]] -= 1
            if window[s[left]] == 0:
                del window[s[left]]
            left += 1
        
        # 3. 更新结果
        max_len = max(max_len, right - left + 1)
    
    return max_len
```

### **2. 动态规划（DP）**
- **适用场景**：  
  - 涉及**子串计数**或**复杂条件判断**（如回文子串、编辑距离）。  
  - 时间复杂度：通常 **O(n²)**。  
- **经典问题**：  
  - [5. 最长回文子串](https://leetcode.com/problems/longest-palindromic-substring/)  
  - [647. 回文子串](https://leetcode.com/problems/palindromic-substrings/)  

#### **回文子串DP模板**
```python
def countSubstrings(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]  # dp[i][j]表示s[i..j]是否回文
    count = 0
    
    for i in range(n-1, -1, -1):  # 倒序遍历
        for j in range(i, n):
            if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1]):
                dp[i][j] = True
                count += 1
    return count
```

### **3. 前缀和 + 哈希表**
- **适用场景**：  
  - 解决**子串和等于目标值**的问题（如和为K的子数组）。  
  - 时间复杂度：**O(n)**。  
- **例题**：  
  - [560. 和为K的子数组](https://leetcode.com/problems/subarray-sum-equals-k/)  

#### **前缀和模板**
```python
def subarraySum(nums, k):
    prefix_sum = {0: 1}  # 前缀和 -> 出现次数
    total = 0
    count = 0
    
    for num in nums:
        total += num
        if total - k in prefix_sum:  # 关键：total - prefix = k
            count += prefix_sum[total - k]
        prefix_sum[total] = prefix_sum.get(total, 0) + 1
    return count
```

### **4. 暴力枚举（仅限小规模数据）**
- **适用场景**：  
  - 数据量极小（n ≤ 100），或作为其他方法的验证工具。  
  - 时间复杂度：**O(n³)**（三层循环）。  

#### **暴力枚举子串**
```python
def all_substrings(s):
    n = len(s)
    res = []
    for i in range(n):
        for j in range(i+1, n+1):
            res.append(s[i:j])
    return res
```

### **5. 字符串匹配算法**
- **适用场景**：  
  - 判断一个字符串是否是另一个的子串（如`str.find()`的实现）。  
  - 经典算法：KMP、Rabin-Karp（滚动哈希）。  
- **例题**：  
  - [28. 实现 strStr()](https://leetcode.com/problems/implement-strstr/)  

---

## **三、子串问题分类与例题**
### **1. 无重复字符的最长子串**
- **解法**：滑动窗口 + 哈希表记录字符最后位置。  
- **优化点**：直接用数组代替哈希表（ASCII码范围0-127）。  

### **2. 覆盖目标字符的最短子串**
- **解法**：滑动窗口 + 哈希表统计目标字符需求。  
- **关键**：用`valid`变量统计已满足条件的字符数。  

### **3. 回文子串计数**
- **解法**：中心扩展法或DP。  
- **技巧**：遍历时同时处理奇偶长度回文（如`aba`和`aa`）。  

### **4. 字母异位词子串**
- **解法**：滑动窗口 + 固定长度哈希比较。  
- **例题**：  
  - [438. 找到字符串中所有字母异位词](https://leetcode.com/problems/find-all-anagrams-in-a-string/)  

---

## **四、优化技巧**
1. **空间优化**：  
   - 用**数组代替哈希表**（如字符频率统计用`count = [0] * 128`）。  
2. **剪枝策略**：  
   - 在滑动窗口中，若当前窗口长度已小于已知最优解，直接跳过后续检查。  
3. **预处理**：  
   - 对字符串进行预处理（如计算前缀和、哈希值）以加速查询。  

---

## **五、高频面试问题**
1. **如何判断滑动窗口是否适用？**  
   - 若问题要求**连续子串**且具有**单调性**（如“最长/最短”），优先考虑滑动窗口。  
2. **DP解子串问题的核心是什么？**  
   - 定义`dp[i][j]`表示子串`s[i..j]`的状态，通过状态转移填充表格。  
3. **KMP算法的核心思想？**  
   - 利用**部分匹配表（PMT）**跳过不必要的比较，将时间复杂度从O(mn)降至O(m+n)。  

---

通过掌握这些方法，可以系统化解决绝大多数子串问题。如果需要更深入的例题解析或代码实现细节，欢迎继续提问！
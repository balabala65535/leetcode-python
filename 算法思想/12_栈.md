### **栈（Stack）知识体系详解**

栈是一种**后进先出（LIFO）**的线性数据结构，是算法和系统设计中最基础且高频的数据结构之一。以下是栈的系统化整理，涵盖核心操作、实现方式、应用场景及解题技巧。

---

## **一、栈的核心特性**
### **1. 基本性质**
- **操作规则**：后进先出（Last In, First Out, LIFO）。
- **核心操作**：
  - `push(x)`：元素入栈（O(1)）。
  - `pop()`：栈顶元素出栈（O(1)）。
  - `peek()`：获取栈顶元素（O(1)）。
  - `is_empty()`：判断栈是否为空（O(1)）。
- **实现方式**：
  - **数组（顺序栈）**：适合静态大小或预知最大容量的场景。
  - **链表（链式栈）**：动态扩容更灵活。

### **2. 栈的存储结构**
#### **数组实现（Python列表）**
```python
class ArrayStack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def pop(self):
        return self.stack.pop()

    def peek(self):
        return self.stack[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.stack) == 0
```
#### **链表实现**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedStack:
    def __init__(self):
        self.top = None

    def push(self, x):
        new_node = ListNode(x)
        new_node.next = self.top
        self.top = new_node

    def pop(self):
        if not self.top:
            return None
        val = self.top.val
        self.top = self.top.next
        return val

    def peek(self):
        return self.top.val if self.top else None

    def is_empty(self):
        return self.top is None
```

---

## **二、栈的四大经典应用**
### **1. 括号匹配**
**问题类型**：检查括号是否成对且顺序合法。  
**例题**：  
- [20. 有效的括号](https://leetcode.com/problems/valid-parentheses/)  
- [32. 最长有效括号](https://leetcode.com/problems/longest-valid-parentheses/)  

**解题模板**：
```python
def is_valid(s: str) -> bool:
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return False
        else:
            stack.append(char)
    return not stack
```

### **2. 表达式求值**
**问题类型**：中缀表达式转后缀表达式，或直接计算结果。  
**例题**：  
- [150. 逆波兰表达式求值](https://leetcode.com/problems/evaluate-reverse-polish-notation/)  
- [224. 基本计算器](https://leetcode.com/problems/basic-calculator/)  

**逆波兰表达式求值**：
```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in "+-*/":
            b = stack.pop()
            a = stack.pop()
            if token == '+': stack.append(a + b)
            elif token == '-': stack.append(a - b)
            elif token == '*': stack.append(a * b)
            elif token == '/': stack.append(int(a / b))  # 注意整除
        else:
            stack.append(int(token))
    return stack.pop()
```

### **3. 单调栈**
**问题类型**：寻找下一个更大/更小元素。  
**例题**：  
- [496. 下一个更大元素 I](https://leetcode.com/problems/next-greater-element-i/)  
- [739. 每日温度](https://leetcode.com/problems/daily-temperatures/)  

**模板代码**（每日温度）：
```python
def dailyTemperatures(T):
    stack = []
    res = [0] * len(T)
    for i, temp in enumerate(T):
        while stack and T[stack[-1]] < temp:
            prev_idx = stack.pop()
            res[prev_idx] = i - prev_idx
        stack.append(i)
    return res
```

### **4. 函数调用栈**
**问题类型**：递归或系统栈的模拟（如DFS、回溯）。  
**例题**：  
- [94. 二叉树的中序遍历](https://leetcode.com/problems/binary-tree-inorder-traversal/)（迭代版）  
- [144. 二叉树的前序遍历](https://leetcode.com/problems/binary-tree-preorder-traversal/)  

**非递归中序遍历**：
```python
def inorderTraversal(root):
    stack, res = [], []
    curr = root
    while curr or stack:
        while curr:
            stack.append(curr)
            curr = curr.left
        curr = stack.pop()
        res.append(curr.val)
        curr = curr.right
    return res
```

---

## **三、栈的进阶技巧**
### **1. 双栈实现队列**
**问题**：用栈模拟队列的FIFO特性。  
**例题**：  
- [232. 用栈实现队列](https://leetcode.com/problems/implement-queue-using-stacks/)  

**代码实现**：
```python
class MyQueue:
    def __init__(self):
        self.in_stack = []
        self.out_stack = []

    def push(self, x):
        self.in_stack.append(x)

    def pop(self):
        if not self.out_stack:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
        return self.out_stack.pop()

    def peek(self):
        if not self.out_stack:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
        return self.out_stack[-1]

    def empty(self):
        return not self.in_stack and not self.out_stack
```

### **2. 最小栈**
**问题**：在O(1)时间内获取栈的最小值。  
**例题**：  
- [155. 最小栈](https://leetcode.com/problems/min-stack/)  

**代码实现**：
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.min_stack[-1]
```

### **3. 栈的递归转迭代**
**场景**：将递归算法（如DFS）改为显式栈实现，避免栈溢出。  
**示例**（二叉树前序遍历）：
```python
def preorderTraversal(root):
    if not root:
        return []
    stack, res = [root], []
    while stack:
        node = stack.pop()
        res.append(node.val)
        if node.right: stack.append(node.right)  # 右子节点先入栈
        if node.left: stack.append(node.left)
    return res
```

---

## **四、高频面试问题**
1. **栈和队列的区别？**  
   - 栈是LIFO，队列是FIFO。
2. **如何用栈实现队列？时间复杂度如何？**  
   - 双栈法，均摊时间复杂度为O(1)。
3. **单调栈的核心思想是什么？**  
   - 维护栈内元素的单调性，快速找到下一个更大/更小元素。
4. **递归为什么可以用栈实现？**  
   - 递归本质是函数调用栈的压栈和出栈过程。

---

## **五、总结与模板**
### **栈的适用场景**
| **问题类型**       | **例题**                                                                 | **核心技巧**                     |
|--------------------|-------------------------------------------------------------------------|----------------------------------|
| 括号匹配           | [20. 有效的括号](https://leetcode.com/problems/valid-parentheses/)       | 栈顶匹配最近的开括号             |
| 表达式求值         | [150. 逆波兰表达式](https://leetcode.com/problems/evaluate-reverse-polish-notation/) | 操作符优先级处理                 |
| 单调栈             | [739. 每日温度](https://leetcode.com/problems/daily-temperatures/)       | 维护递减栈                       |
| 系统栈模拟         | [94. 二叉树中序遍历](https://leetcode.com/problems/binary-tree-inorder-traversal/) | 显式栈替代递归                   |

### **Python栈操作模板**
```python
stack = []
stack.append(x)      # 入栈
top = stack[-1]      # 查看栈顶（不弹出）
stack.pop()          # 出栈
is_empty = not stack # 判断空栈
```

掌握栈的关键在于理解其**LIFO特性**和**边界条件处理**，通过经典问题练习可快速提升应用能力！
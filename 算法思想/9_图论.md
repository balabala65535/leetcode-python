### **图论（Graph Theory）知识体系详解**  
图论是算法与数据结构中的核心领域，广泛应用于社交网络、路径规划、推荐系统等场景。以下是图论的系统化整理，涵盖**基础概念、存储方式、遍历方法、经典算法及例题**。

---

## **一、图的基础概念**
### **1. 图的分类**
| **类型**         | **特点**                                  | **示例**                     |
|------------------|------------------------------------------|-----------------------------|
| **无向图**       | 边无方向，用 `(u, v)` 表示                | 社交网络中的好友关系         |
| **有向图**       | 边有方向，用 `<u, v>` 表示                | 网页链接、任务依赖关系       |
| **加权图**       | 边带权值（如距离、成本）                  | 地图导航中的道路长度         |
| **无权图**       | 边无权重                                  | 简单的社交关系图             |
| **连通图**       | 任意两点间存在路径                        | 全连通的城市交通网           |
| **非连通图**     | 存在孤立节点或子图                        | 岛屿间的航线图               |

### **2. 图的术语**
- **顶点（Vertex）**：图中的节点。
- **边（Edge）**：顶点之间的连接。
- **度（Degree）**：无向图中顶点的边数；有向图分**入度**和**出度**。
- **路径（Path）**：顶点序列，相邻顶点间有边。
- **环（Cycle）**：起点和终点相同的路径。

---

## **二、图的存储方式**
### **1. 邻接矩阵**
- **适用场景**：稠密图（边数接近顶点数²）。
- **空间复杂度**：O(V²)。
- **特点**：快速判断两顶点是否相邻，但浪费空间（稀疏图不推荐）。

```python
# 邻接矩阵示例（无向图）
graph = [
    [0, 1, 1, 0],  # 顶点0与1、2相连
    [1, 0, 0, 1],  # 顶点1与0、3相连
    [1, 0, 0, 1],
    [0, 1, 1, 0]
]
```

### **2. 邻接表**
- **适用场景**：稀疏图（边数远小于顶点数²）。
- **空间复杂度**：O(V + E)。
- **特点**：节省空间，适合遍历邻接节点。

```python
# 邻接表示例（有向图）
graph = {
    0: [1, 2],  # 顶点0指向1、2
    1: [3],
    2: [3],
    3: []
}
```

### **3. 边列表**
- **适用场景**：需要直接处理边的算法（如Kruskal算法）。
- **存储方式**：直接存储所有边的集合。

```python
edges = [(0, 1), (0, 2), (1, 3), (2, 3)]  # (u, v) 或 (u, v, weight)
```

---

## **三、图的遍历**
### **1. 深度优先搜索（DFS）**
- **核心思想**：递归或栈实现，沿一条路径深入到底，再回溯。
- **应用场景**：连通性检测、拓扑排序、寻找环。

```python
def dfs(graph, node, visited):
    if node not in visited:
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)
```

### **2. 广度优先搜索（BFS）**
- **核心思想**：队列实现，逐层扩展。
- **应用场景**：最短路径（无权图）、层级遍历。

```python
from collections import deque
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

---

## **四、经典图算法**
### **1. 最短路径算法**
| **算法**         | **适用场景**              | **时间复杂度**       | **示例问题**                     |
|------------------|--------------------------|----------------------|----------------------------------|
| **Dijkstra**     | 无负权边的加权图          | O((V+E)logV)         | 地图导航（非负权最短路径）       |
| **Bellman-Ford** | 含负权边的加权图          | O(VE)                | 检测负权环、金融套利问题         |
| **Floyd-Warshall** | 所有顶点对的最短路径      | O(V³)                | 多源最短路径（如城市间距离矩阵） |

### **2. 最小生成树（MST）**
| **算法**         | **核心思想**              | **时间复杂度**       | **示例问题**                     |
|------------------|--------------------------|----------------------|----------------------------------|
| **Kruskal**      | 贪心 + 并查集             | O(ElogE)             | 电网布线、通信网络建设           |
| **Prim**        | 贪心 + 优先队列           | O(ElogV)             | 道路规划、管道铺设               |

### **3. 拓扑排序**
- **适用场景**：有向无环图（DAG）的任务调度、依赖解析。
- **算法**：基于BFS（Kahn算法）或DFS。

```python
# Kahn算法（BFS实现）
def topological_sort(graph):
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    queue = deque([u for u in in_degree if in_degree[u] == 0])
    result = []
    while queue:
        u = queue.popleft()
        result.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    return result if len(result) == len(graph) else []  # 判断是否有环
```

### **4. 连通性与强连通分量（SCC）**
- **Tarjan算法**：DFS实现，用于寻找有向图的强连通分量。
- **Union-Find**：无向图的连通性检测与合并操作。

---

## **五、高频图论问题**
### **1. 基础问题**
| **题目**                                                                 | **解法**                | **关键点**                     |
|--------------------------------------------------------------------------|-------------------------|--------------------------------|
| [200. 岛屿数量](https://leetcode.com/problems/number-of-islands/)        | DFS/BFS                 | 矩阵转邻接表，连通块计数       |
| [207. 课程表](https://leetcode.com/problems/course-schedule/)            | 拓扑排序（检测环）      | 判断DAG能否完成所有任务        |

### **2. 进阶问题**
| **题目**                                                                 | **解法**                | **关键点**                     |
|--------------------------------------------------------------------------|-------------------------|--------------------------------|
| [743. 网络延迟时间](https://leetcode.com/problems/network-delay-time/)   | Dijkstra/Bellman-Ford   | 单源最短路径的最大值           |
| [1584. 连接所有点的最小费用](https://leetcode.com/problems/min-cost-to-connect-all-points/) | Kruskal/Prim           | 曼哈顿距离建图 + MST           |

---

## **六、图论优化技巧**
1. **稠密图 vs 稀疏图**：
   - 稠密图用邻接矩阵，稀疏图用邻接表。
2. **双向BFS**：  
   - 适用于已知起点和终点的最短路径问题（如单词接龙）。
3. **A*算法**：  
   - 结合Dijkstra和启发式搜索，适合地图导航。

---

## **七、面试高频考点**
1. **如何选择DFS还是BFS？**  
   - DFS适合找所有解或检测环，BFS适合最短路径或层级遍历。
2. **Dijkstra为什么不能处理负权边？**  
   - 贪心策略假设当前最短路径全局最优，负权边会破坏这一性质。
3. **如何判断图是否为二分图？**  
   - BFS/DFS染色法，相邻节点颜色不同则合法。

---

掌握图论的核心算法和问题分类后，可以系统化解决90%的面试题。如需更深入的例题解析或代码实现细节，欢迎继续提问！
### **矩阵（二维数组）算法知识体系详解**  
矩阵是二维数组的高级形式，广泛用于图像处理、动态规划、图论等领域。以下是矩阵问题的**系统化整理**，涵盖核心操作、解题方法、经典例题及优化技巧。

---

## **一、矩阵的核心操作**
### **1. 基础操作**
| **操作**               | **时间复杂度** | **典型应用**                     |
|------------------------|----------------|----------------------------------|
| 遍历                   | O(m×n)         | 搜索、统计元素                   |
| 转置                   | O(m×n)         | 行列交换（如旋转矩阵）           |
| 对角线访问             | O(min(m,n))    | 处理对角线元素                   |

### **2. 特殊遍历方式**
- **螺旋遍历**：按层顺时针/逆时针输出元素。  
- **锯齿遍历（Zigzag）**：按对角线方向遍历。  
- **分层遍历**：从外到内或从内到外逐层处理。  

---

## **二、矩阵问题的五大解法**
### **1. 模拟法**
**适用场景**：直接按题目要求模拟操作（如旋转、螺旋遍历）。  
**例题**：  
- [48. 旋转图像](https://leetcode.com/problems/rotate-image/)  
- [54. 螺旋矩阵](https://leetcode.com/problems/spiral-matrix/)  

**旋转图像代码**（先转置再翻转）：  
```python
def rotate(matrix):
    n = len(matrix)
    # 转置
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 每行翻转
    for row in matrix:
        row.reverse()
```

### **2. 动态规划（DP）**
**适用场景**：矩阵中的路径计数、最值问题（通常依赖相邻格子状态）。  
**例题**：  
- [64. 最小路径和](https://leetcode.com/problems/minimum-path-sum/)  
- [62. 不同路径](https://leetcode.com/problems/unique-paths/)  

**最小路径和模板**：  
```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    # 初始化第一行和第一列
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    # 状态转移
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    return dp[-1][-1]
```

### **3. 深度优先搜索（DFS）/广度优先搜索（BFS）**
**适用场景**：矩阵中的连通性问题（如岛屿、迷宫）。  
**例题**：  
- [200. 岛屿数量](https://leetcode.com/problems/number-of-islands/)  
- [994. 腐烂的橘子](https://leetcode.com/problems/rotting-oranges/)  

**岛屿数量DFS代码**：  
```python
def numIslands(grid):
    def dfs(i, j):
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
            return
        grid[i][j] = '0'  # 标记为已访问
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    
    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    return count
```

### **4. 前缀和（二维）**
**适用场景**：快速计算子矩阵的和（适合频繁查询）。  
**例题**：  
- [304. 二维区域和检索 - 矩阵不可变](https://leetcode.com/problems/range-sum-query-2d-immutable/)  

**二维前缀和模板**：  
```python
class NumMatrix:
    def __init__(self, matrix):
        m, n = len(matrix), len(matrix[0]) if matrix else 0
        self.prefix = [[0] * (n+1) for _ in range(m+1)]
        for i in range(m):
            for j in range(n):
                self.prefix[i+1][j+1] = matrix[i][j] + self.prefix[i][j+1] + self.prefix[i+1][j] - self.prefix[i][j]
    
    def sumRegion(self, row1, col1, row2, col2):
        return self.prefix[row2+1][col2+1] - self.prefix[row1][col2+1] - self.prefix[row2+1][col1] + self.prefix[row1][col1]
```

### **5. 数学与规律**
**适用场景**：矩阵中的数学规律（如杨辉三角、对角线遍历）。  
**例题**：  
- [118. 杨辉三角](https://leetcode.com/problems/pascals-triangle/)  
- [498. 对角线遍历](https://leetcode.com/problems/diagonal-traverse/)  

**杨辉三角代码**：  
```python
def generate(numRows):
    res = []
    for i in range(numRows):
        row = [1] * (i+1)
        for j in range(1, i):
            row[j] = res[i-1][j-1] + res[i-1][j]
        res.append(row)
    return res
```

---

## **三、高频问题分类**
### **1. 路径问题**
| 问题类型               | 解法                | 例题                                                                 |
|------------------------|---------------------|----------------------------------------------------------------------|
| 最小路径和             | 动态规划            | [64. 最小路径和](https://leetcode.com/problems/minimum-path-sum/)    |
| 不同路径               | DP或组合数学        | [62. 不同路径](https://leetcode.com/problems/unique-paths/)          |

### **2. 搜索与连通性**
| 问题类型               | 解法                | 例题                                                                 |
|------------------------|---------------------|----------------------------------------------------------------------|
| 岛屿数量               | DFS/BFS             | [200. 岛屿数量](https://leetcode.com/problems/number-of-islands/)    |
| 单词搜索               | 回溯法              | [79. 单词搜索](https://leetcode.com/problems/word-search/)           |

### **3. 矩阵变换**
| 问题类型               | 解法                | 例题                                                                 |
|------------------------|---------------------|----------------------------------------------------------------------|
| 旋转图像               | 模拟法              | [48. 旋转图像](https://leetcode.com/problems/rotate-image/)          |
| 矩阵置零               | 标记法              | [73. 矩阵置零](https://leetcode.com/problems/set-matrix-zeroes/)     |

---

## **四、优化技巧**
1. **空间优化**：  
   - DP问题中，用滚动数组或原地修改代替二维DP表（如`grid[i][j]`直接存储状态）。  
2. **边界处理**：  
   - 检查矩阵是否为空或只有一行/一列。  
3. **方向数组**：  
   - 在DFS/BFS中，用`dirs = [(-1,0), (1,0), (0,-1), (0,1)]`简化代码。  

---

## **五、面试高频考点**
1. **如何优化矩阵的DFS/BFS空间复杂度？**  
   - 修改原矩阵标记访问状态（如将`'1'`改为`'0'`），避免额外`visited`数组。  
2. **如何证明动态规划状态转移的正确性？**  
   - 通过子问题推导（如`dp[i][j]`只能从上方或左方格子转移）。  
3. **如何处理超大矩阵的稀疏性问题？**  
   - 使用哈希表存储非零元素（如稀疏矩阵的压缩存储）。  

---

掌握这些方法后，矩阵类问题可以系统化解决。如果需要更具体的题目解析或代码实现细节，欢迎继续提问！
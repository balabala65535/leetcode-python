### **贪心算法（Greedy Algorithm）知识体系详解**

贪心算法是一种在**每一步选择中都采取当前状态下最优决策**的算法策略，希望通过局部最优解堆叠出全局最优解。以下是系统化的贪心算法知识体系整理：

---

## **一、贪心算法的核心思想**
### **1. 基本特点**
- **局部最优选择**：每一步只考虑当前最优解，不回溯。
- **无后效性**：当前决策不影响后续子问题的结构。
- **高效性**：通常时间复杂度较低（O(n) 或 O(n log n)）。

### **2. 适用条件**
贪心算法能解决的问题通常满足以下两个性质：
1. **贪心选择性质**：全局最优解可以通过局部最优选择逐步构建。
2. **最优子结构**：问题的最优解包含子问题的最优解。

### **3. 与动态规划的区别**
| **贪心算法**               | **动态规划**                  |
|---------------------------|------------------------------|
| 局部最优 → 全局最优        | 考虑所有子问题的解           |
| 无回溯                    | 可能需回溯（如状态转移）     |
| 通常更高效                | 通常更通用但复杂度更高       |

---

## **二、贪心算法的通用解决步骤**
1. **问题分解**：将问题分解为多个子问题。
2. **贪心选择**：对每个子问题做出局部最优选择。
3. **合并结果**：将局部最优解合并为全局解。

---

## **三、贪心算法的经典应用场景**
### **1. 区间调度问题**
**问题类型**：在一组区间中选出最多不重叠的区间。  
**例题**：  
- [435. 无重叠区间](https://leetcode.com/problems/non-overlapping-intervals/)  
- [452. 用最少数量的箭引爆气球](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)  

**贪心策略**：按区间右端点排序，优先选择结束早的区间。  
**代码示例**：
```python
def eraseOverlapIntervals(intervals):
    if not intervals: return 0
    intervals.sort(key=lambda x: x[1])  # 按右端点排序
    count = 0
    end = intervals[0][1]
    for i in range(1, len(intervals)):
        if intervals[i][0] < end:  # 重叠则需删除
            count += 1
        else:
            end = intervals[i][1]  # 不重叠则更新右端点
    return count
```

### **2. 分配问题**
**问题类型**：将资源分配给满足某些条件的对象。  
**例题**：  
- [455. 分发饼干](https://leetcode.com/problems/assign-cookies/)  
- [135. 分发糖果](https://leetcode.com/problems/candy/)  

**贪心策略**：优先满足最小需求或最小消耗。  
**代码示例**（分发饼干）：
```python
def findContentChildren(g, s):
    g.sort()
    s.sort()
    child = cookie = 0
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:
            child += 1
        cookie += 1
    return child
```

### **3. 跳跃游戏问题**
**问题类型**：判断是否能到达终点或计算最小步数。  
**例题**：  
- [55. 跳跃游戏](https://leetcode.com/problems/jump-game/)  
- [45. 跳跃游戏 II](https://leetcode.com/problems/jump-game-ii/)  

**贪心策略**：维护当前能到达的最远距离。  
**代码示例**（跳跃游戏II）：
```python
def jump(nums):
    jumps = 0
    current_end = farthest = 0
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
    return jumps
```

### **4.  Huffman编码**
**问题类型**：构造最优前缀编码树，用于数据压缩。  
**贪心策略**：每次合并频率最小的两个节点。

---

## **四、贪心算法的证明方法**
贪心算法的正确性通常需要数学证明，常见方法包括：
1. **交换论证**：证明任何非贪心选择的解都可以通过交换调整为贪心解。
2. **归纳法**：证明贪心选择在每一步都保持最优性。
3. **反证法**：假设存在更优解，推导矛盾。

---

## **五、贪心算法的局限性**
贪心算法**不能解决所有问题**，例如：
- **0-1背包问题**：贪心选择无法保证全局最优。
- **部分最短路径问题**：如含负权边的图。

---

## **六、高频面试问题**
1. **如何判断一个问题是否适合贪心算法？**  
   - 验证是否满足贪心选择性质和最优子结构。
2. **贪心算法的时间复杂度是多少？**  
   - 通常为 O(n log n)（排序）或 O(n)（线性遍历）。
3. **贪心算法在哪些情况下会失败？**  
   - 当局部最优无法保证全局最优时（如0-1背包问题）。

---

## **七、总结与模板**
### **贪心算法适用场景**
| **问题类型**       | **例题**                                                                 | **贪心策略**                     |
|--------------------|-------------------------------------------------------------------------|----------------------------------|
| 区间调度           | [435. 无重叠区间](https://leetcode.com/problems/non-overlapping-intervals/) | 按右端点排序，优先选结束早的     |
| 分配问题           | [455. 分发饼干](https://leetcode.com/problems/assign-cookies/)           | 优先满足最小需求                 |
| 跳跃游戏           | [45. 跳跃游戏 II](https://leetcode.com/problems/jump-game-ii/)           | 维护当前能到达的最远距离         |
|  Huffman编码       | 数据压缩问题                                                            | 合并频率最小的节点               |

### **通用解题步骤**
1. **排序或预处理**（如按区间端点、数值大小等）。
2. **遍历并做贪心选择**（如选择不重叠区间、分配资源）。
3. **验证结果是否全局最优**（通常需数学证明）。

---

掌握贪心算法的核心在于**识别问题特征**和**设计局部最优策略**。通过经典例题的练习，可以快速提升对贪心算法的理解和应用能力！
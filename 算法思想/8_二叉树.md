### **二叉树算法知识体系详解**  
二叉树是算法面试中的高频考点，涉及**遍历、递归、分治、DFS/BFS、动态规划**等核心思想。以下是系统化整理，涵盖基础操作、解题框架、经典题型及优化技巧。

---

## **一、二叉树基础**
### **1. 基本概念**
- **节点结构**（以Python为例）：
  ```python
  class TreeNode:
      def __init__(self, val=0, left=None, right=None):
          self.val = val
          self.left = left
          self.right = right
  ```
- **常见类型**：
  - **二叉搜索树（BST）**：左子树值 < 根节点值 < 右子树值（中序遍历有序）。
  - **平衡二叉树（AVL）**：任意节点左右子树高度差 ≤ 1。
  - **完全二叉树**：除最后一层外，其他层节点全部填满。

### **2. 核心操作**
| **操作**       | **时间复杂度** | **空间复杂度** | **关键点**                     |
|----------------|----------------|----------------|--------------------------------|
| 遍历（递归）   | O(n)           | O(h)（递归栈） | 前序、中序、后序、层序         |
| 遍历（迭代）   | O(n)           | O(n)           | 用栈模拟递归                   |
| 插入/删除      | O(h)           | O(h)           | BST中需维护有序性              |

---

## **二、二叉树的四种遍历方式**
### **1. 递归遍历（DFS）**
```python
# 前序遍历（根→左→右）
def preorder(root):
    if not root: return []
    return [root.val] + preorder(root.left) + preorder(root.right)

# 中序遍历（左→根→右，BST中结果为有序序列）
def inorder(root):
    if not root: return []
    return inorder(root.left) + [root.val] + inorder(root.right)

# 后序遍历（左→右→根）
def postorder(root):
    if not root: return []
    return postorder(root.left) + postorder(root.right) + [root.val]
```

### **2. 迭代遍历（栈模拟）**
```python
# 前序遍历（用栈，右子节点先入栈）
def preorder_iter(root):
    if not root: return []
    stack, res = [root], []
    while stack:
        node = stack.pop()
        res.append(node.val)
        if node.right: stack.append(node.right)
        if node.left: stack.append(node.left)
    return res

# 中序遍历（维护当前指针+栈）
def inorder_iter(root):
    stack, res = [], []
    curr = root
    while curr or stack:
        while curr:
            stack.append(curr)
            curr = curr.left
        curr = stack.pop()
        res.append(curr.val)
        curr = curr.right
    return res
```

### **3. 层序遍历（BFS）**
```python
from collections import deque
def levelOrder(root):
    if not root: return []
    queue, res = deque([root]), []
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        res.append(level)
    return res
```

### **4. Morris遍历（O(1)空间）**
- **核心思想**：利用叶子节点的空指针临时存储前驱/后继节点信息。
- **适用场景**：需严格限制空间复杂度时（如面试官要求O(1)空间遍历）。

---

## **三、二叉树解题的五大方法**
### **1. 递归分治**
**适用场景**：大多数二叉树问题（如树的高度、对称性判断）。  
**例题**：  
- [104. 二叉树的最大深度](https://leetcode.com/problems/maximum-depth-of-binary-tree/)  
- [101. 对称二叉树](https://leetcode.com/problems/symmetric-tree/)  

**最大深度代码**：
```python
def maxDepth(root):
    if not root: return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

### **2. 回溯法（路径问题）**
**适用场景**：需记录路径的问题（如路径总和、所有路径）。  
**例题**：  
- [113. 路径总和 II](https://leetcode.com/problems/path-sum-ii/)  
- [257. 二叉树的所有路径](https://leetcode.com/problems/binary-tree-paths/)  

**路径总和II代码**：
```python
def pathSum(root, target):
    def backtrack(node, path, remain):
        if not node: return
        path.append(node.val)
        if not node.left and not node.right and remain == node.val:
            res.append(list(path))
        backtrack(node.left, path, remain - node.val)
        backtrack(node.right, path, remain - node.val)
        path.pop()
    
    res = []
    backtrack(root, [], target)
    return res
```

### **3. DFS/BFS变形**
**适用场景**：层序遍历、锯齿遍历、右视图等。  
**例题**：  
- [199. 二叉树的右视图](https://leetcode.com/problems/binary-tree-right-side-view/)  
- [103. 二叉树的锯齿形层序遍历](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)  

**右视图代码**：
```python
def rightSideView(root):
    if not root: return []
    queue, res = deque([root]), []
    while queue:
        res.append(queue[-1].val)  # 每层最后一个节点
        for _ in range(len(queue)):
            node = queue.popleft()
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
    return res
```

### **4. 二叉搜索树（BST）特性**
**适用场景**：利用BST中序有序性解决问题。  
**例题**：  
- [98. 验证二叉搜索树](https://leetcode.com/problems/validate-binary-search-tree/)  
- [230. 二叉搜索树中第K小的元素](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  

**验证BST代码**：
```python
def isValidBST(root):
    def helper(node, lower=float('-inf'), upper=float('inf')):
        if not node: return True
        if node.val <= lower or node.val >= upper:
            return False
        return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)
    return helper(root)
```

### **5. 动态规划（树形DP）**
**适用场景**：需结合子树状态的问题（如打家劫舍III）。  
**例题**：  
- [337. 打家劫舍 III](https://leetcode.com/problems/house-robber-iii/)  

**树形DP模板**：
```python
def rob(root):
    def dfs(node):
        if not node: return (0, 0)  # (偷当前节点的最大值, 不偷当前节点的最大值)
        left = dfs(node.left)
        right = dfs(node.right)
        rob = node.val + left[1] + right[1]  # 偷当前节点，则子节点不能偷
        not_rob = max(left) + max(right)      # 不偷当前节点，子节点可偷可不偷
        return (rob, not_rob)
    return max(dfs(root))
```

---

## **四、高频面试考点**
1. **如何判断完全二叉树？**  
   - BFS遍历，遇到空节点后不应再出现非空节点。  
2. **如何序列化/反序列化二叉树？**  
   - 前序遍历 + 特殊符号（如`#`）标记空节点（LeetCode 297）。  
3. **二叉树最近公共祖先（LCA）？**  
   - 递归分治：若当前节点是p或q，或左右子树分别包含p和q，则为LCA（LeetCode 236）。  

---

## **五、优化技巧**
1. **剪枝**：在递归中提前终止不符合条件的分支（如BST搜索时利用范围判断）。  
2. **全局变量**：在递归中记录全局状态（如最大路径和、最长直径）。  
3. **迭代代替递归**：避免栈溢出问题（如用栈模拟DFS）。  

---

掌握这些方法后，二叉树问题可系统化解决。如需更深入的题目解析或代码细节，欢迎继续提问！

在 Python 中，**栈（Stack）** 是一种 **后进先出（LIFO, Last In First Out）** 的数据结构，可以用列表（`list`）或 `collections.deque` 高效实现。以下是 Python 栈的实现方式及常见操作：

---

## **1. 使用 Python 列表（`list`）实现栈**
Python 的 `list` 可以直接作为栈使用，因为 `append()` 和 `pop()` 的时间复杂度都是 **O(1)**。

### **基本操作**
| 方法 | 说明 | 时间复杂度 |
|------|------|------------|
| `stack.append(x)` | 入栈（压栈） | **O(1)** |
| `stack.pop()` | 出栈（弹栈） | **O(1)** |
| `stack[-1]` | 查看栈顶（不弹出） | **O(1)** |
| `len(stack)` | 获取栈大小 | **O(1)** |
| `not stack` | 判断栈是否为空 | **O(1)** |

### **代码示例**
```python
stack = []  # 初始化空栈

# 入栈（压栈）
stack.append(1)
stack.append(2)
stack.append(3)

print(stack)  # [1, 2, 3]

# 查看栈顶
top = stack[-1]
print(top)  # 3

# 出栈（弹栈）
popped = stack.pop()
print(popped)  # 3
print(stack)  # [1, 2]

# 判断栈是否为空
is_empty = not stack
print(is_empty)  # False

# 获取栈大小
size = len(stack)
print(size)  # 2
```

---

## **2. 使用 `collections.deque` 实现栈**
`deque`（双端队列）也可以用来实现栈，它的 `append()` 和 `pop()` 操作也是 **O(1)**，并且在某些情况下比 `list` 更高效（特别是数据量较大时）。

### **代码示例**
```python
from collections import deque

stack = deque()  # 初始化空栈

# 入栈
stack.append(1)
stack.append(2)
stack.append(3)

print(stack)  # deque([1, 2, 3])

# 查看栈顶
top = stack[-1]
print(top)  # 3

# 出栈
popped = stack.pop()
print(popped)  # 3
print(stack)  # deque([1, 2])

# 判断栈是否为空
is_empty = not stack
print(is_empty)  # False
```

---

## **3. 栈的常见应用**
### **(1) 括号匹配（判断括号是否成对）**
```python
def is_valid_parentheses(s: str) -> bool:
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping:  # 遇到右括号
            top = stack.pop() if stack else "#"  # 弹出栈顶
            if mapping[char] != top:
                return False
        else:  # 遇到左括号，入栈
            stack.append(char)
    
    return not stack  # 栈空则合法

print(is_valid_parentheses("()[]{}"))  # True
print(is_valid_parentheses("(]"))      # False
```

### **(2) 函数调用栈（递归模拟）**
```python
def factorial(n: int) -> int:
    stack = []
    result = 1
    
    # 模拟递归压栈
    while n > 0:
        stack.append(n)
        n -= 1
    
    # 模拟递归出栈计算
    while stack:
        result *= stack.pop()
    
    return result

print(factorial(5))  # 120
```

### **(3) 浏览器前进后退（双栈实现）**
```python
class BrowserHistory:
    def __init__(self):
        self.back_stack = []  # 后退栈
        self.forward_stack = []  # 前进栈

    def visit(self, url: str):
        self.back_stack.append(url)
        self.forward_stack = []  # 访问新页面时清空前进栈

    def back(self) -> str:
        if len(self.back_stack) > 1:
            self.forward_stack.append(self.back_stack.pop())
            return self.back_stack[-1]
        return "Can't go back."

    def forward(self) -> str:
        if self.forward_stack:
            self.back_stack.append(self.forward_stack.pop())
            return self.back_stack[-1]
        return "Can't go forward."

browser = BrowserHistory()
browser.visit("A")
browser.visit("B")
browser.visit("C")

print(browser.back())    # "B"（从 C 后退到 B）
print(browser.back())    # "A"（从 B 后退到 A）
print(browser.forward()) # "B"（从 A 前进到 B）
```

---

## **4. 栈 vs 队列**
| 特性 | 栈（Stack） | 队列（Queue） |
|------|------------|--------------|
| **规则** | 后进先出（LIFO） | 先进先出（FIFO） |
| **核心操作** | `push` / `pop` | `enqueue` / `dequeue` |
| **Python 实现** | `list` / `deque` | `queue.Queue` / `collections.deque` |
| **典型应用** | 函数调用、括号匹配、DFS | 任务调度、BFS、消息队列 |

---

## **5. 总结**
- **Python 栈的实现**：
  - 推荐使用 `list`（`append()` + `pop()`）或 `collections.deque`。
  - 避免用 `list.insert(0, x)` 或 `list.pop(0)`（时间复杂度 **O(n)**）。
- **栈的应用**：
  - 括号匹配、函数调用、DFS、撤销操作（如 `Ctrl+Z`）。
- **栈 vs 队列**：
  - 栈是 **LIFO**，队列是 **FIFO**，选择合适的数据结构能提高效率。

如果你需要线程安全的栈，可以使用 `queue.LifoQueue`（基于 `queue` 模块）。

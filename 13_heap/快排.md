快速排序（Quick Sort）是一种高效的**分治排序算法**，由英国计算机科学家 Tony Hoare 在 1959 年提出。它的核心思想是通过一趟排序将待排数据分割成独立的两部分，其中一部分的所有数据都比另一部分小，然后递归地对这两部分进行排序，最终完成整个序列的排序。

---

### **快排的核心步骤**
1. **选择基准（Pivot）**：  
   从数组中选择一个元素作为基准（通常选第一个、最后一个或随机一个元素）。
2. **分区（Partition）**：  
   将数组分为两部分，使得：
   - 左边部分的元素都 **≤ 基准**，
   - 右边部分的元素都 **≥ 基准**。
   - 基准元素最终位于正确的位置（即排序后的最终位置）。
3. **递归排序**：  
   对左右两部分子数组递归地重复上述过程，直到子数组长度为 1 或 0（已有序）。

---

### **示例（升序排序）**
假设数组为 `[3, 6, 8, 10, 1, 2, 1]`，选择最后一个元素 `1` 作为基准：
1. **分区过程**：  
   - 将小于等于 `1` 的元素移到左侧，大于 `1` 的元素移到右侧。  
   - 分区后可能变为 `[1, 1, 2, 3, 6, 10, 8]`（基准 `1` 的位置已固定）。
2. **递归排序**：  
   - 对左子数组 `[1, 1]` 和右子数组 `[2, 3, 6, 10, 8]` 分别递归执行快排。

---

### **代码实现（Python）**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]  # 选择中间元素作为基准（也可选其他位置）
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

---

### **快排的特点**
1. **时间复杂度**：  
   - **平均情况**：O(n log n)（每次分区接近均分）。  
   - **最坏情况**：O(n²)（如数组已有序且基准选择不当，但可通过随机化避免）。  
2. **空间复杂度**：O(log n)（递归栈空间）。  
3. **原地排序**：通过原地分区（如 Lomuto 或 Hoare 分区）可优化空间复杂度。  
4. **不稳定排序**：相同元素的相对位置可能改变。

---

### **优化方法**
- **随机化基准**：避免最坏情况（如随机选择基准）。  
- **三数取中法**：选择头、中、尾的中位数作为基准。  
- **小数组切换插入排序**：当子数组较小时（如长度 ≤ 10），使用插入排序减少递归开销。

快排是实际应用中最高效的排序算法之一，被广泛用于编程语言的标准库（如 C++ 的 `std::sort`、Python 的 `list.sort`）。
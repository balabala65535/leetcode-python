算法的核心思想是解决问题的通用方法论，不同的思想适用于不同的问题场景。以下是算法中最核心的 **10 大思想**，它们构成了算法设计和优化的基础：

---

## **1. 分治（Divide and Conquer）**
**思想**：将大问题分解为多个 **相同或相似的小问题**，递归解决后合并结果。  
**特点**：
- 子问题相互独立，适合递归。
- 通常用 **Master 定理** 分析时间复杂度。  

**典型应用**：
- 归并排序（Merge Sort）
- 快速排序（Quick Sort）
- 二分查找（Binary Search）
- 汉诺塔问题  

**伪代码**：
```python
def divide_and_conquer(problem):
    if problem is small:  # 基本情况
        return solve(problem)
    subproblems = split(problem)  # 分解问题
    results = [divide_and_conquer(p) for p in subproblems]
    return merge(results)  # 合并结果
```

---

## **2. 动态规划（Dynamic Programming, DP）**
**思想**：通过 **存储子问题的解** 避免重复计算，用空间换时间。  
**特点**：
- 适用于 **重叠子问题** 和 **最优子结构**。
- 分为 **自顶向下（记忆化搜索）** 和 **自底向上（填表）**。  

**典型应用**：
- 斐波那契数列（Fibonacci）
- 背包问题（0-1 Knapsack）
- 最长公共子序列（LCS）
- 最短路径（Floyd-Warshall）  

**伪代码（自底向上）**：
```python
dp = [0] * (n+1)  # 初始化 DP 表
dp[0], dp[1] = base_cases  # 边界条件
for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]  # 状态转移方程
return dp[n]
```

---

## **3. 贪心（Greedy）**
**思想**：每一步选择 **当前最优解**，希望最终达到全局最优。  
**特点**：
- 高效但不一定能得到全局最优解（需证明正确性）。
- 无后效性（当前选择不影响后续决策）。  

**典型应用**：
- 霍夫曼编码（Huffman Coding）
- Dijkstra 最短路径算法
- 最小生成树（Prim/Kruskal）
- 找零钱问题（硬币面额合适时）  

**伪代码**：
```python
def greedy(choices):
    result = []
    while problem_not_solved:
        best = select_best(choices)  # 选择当前最优
        result.append(best)
        update_problem(best)  # 更新问题状态
    return result
```

---

## **4. 回溯（Backtracking）**
**思想**：通过 **递归尝试所有可能**，发现错误时回退（回溯）。  
**特点**：
- 本质是 **DFS + 状态重置**。
- 通过剪枝优化效率。  

**典型应用**：
- 全排列（Permutations）
- N 皇后问题
- 数独求解
- 组合问题（Subsets）  

**伪代码**：
```python
def backtrack(path, choices):
    if meet_condition:
        result.add(path)
        return
    for choice in choices:
        if not valid(choice):
            continue  # 剪枝
        path.add(choice)
        backtrack(path, new_choices)  # 递归
        path.remove(choice)  # 回溯
```

---

## **5. 搜索（Search）**
**思想**：系统地遍历所有可能的解空间。  
**分类**：
- **深度优先搜索（DFS）**：递归或栈实现，适合回溯问题。
- **广度优先搜索（BFS）**：队列实现，适合最短路径问题。  

**典型应用**：
- DFS：迷宫问题、图的连通性
- BFS：社交网络好友推荐、单词接龙  

**DFS vs BFS**：
| 特性          | DFS               | BFS               |
|---------------|-------------------|-------------------|
| **数据结构**   | 栈（递归）        | 队列              |
| **空间复杂度** | O(树高)           | O(树宽)           |
| **适用场景**   | 所有解、回溯      | 最短路径、层序遍历 |

---

## **6. 双指针（Two Pointers）**
**思想**：用两个指针协同遍历数据，降低时间复杂度。  
**变种**：
- **同向指针**：快慢指针（如链表判环）。
- **相向指针**：左右逼近（如两数之和）。  

**典型应用**：
- 有序数组的两数之和（LeetCode 167）
- 链表的快慢指针（判断环）
- 滑动窗口（子数组问题）  

**伪代码（快慢指针）**：
```python
slow, fast = head, head
while fast and fast.next:
    slow = slow.next      # 慢指针走一步
    fast = fast.next.next # 快指针走两步
    if slow == fast:      # 相遇说明有环
        return True
```

---

## **7. 滑动窗口（Sliding Window）**
**思想**：通过维护一个窗口（通常用双指针），高效解决子数组/子串问题。  
**特点**：
- 窗口大小可固定或可变。
- 将 O(n²) 暴力解法优化为 O(n)。  

**典型应用**：
- 最长无重复子串（LeetCode 3）
- 最小覆盖子串（LeetCode 76）
- 大小为 K 的子数组最大和  

**伪代码**：
```python
left = 0
for right in range(len(s)):
    window.add(s[right])      # 扩展右边界
    while invalid(window):    # 收缩左边界
        window.remove(s[left])
        left += 1
    update_result(window)     # 更新结果
```

---

## **8. 位运算（Bit Manipulation）**
**思想**：利用二进制位的特性高效计算。  
**常用技巧**：
- `n & (n-1)`：去掉最低位的 1（如统计 1 的个数）。
- `^`：异或实现去重（如只出现一次的数字）。  

**典型应用**：
- 统计二进制中 1 的个数（LeetCode 191）
- 只出现一次的数字（LeetCode 136）
- 布隆过滤器（Bloom Filter）  

**示例（异或去重）**：
```python
a ^ a = 0    # 相同数异或为 0
a ^ 0 = a    # 任何数与 0 异或不变
nums = [2,1,2]
res = 0
for num in nums:
    res ^= num  # res = 1（唯一出现的数）
```

---

## **9. 数学与数论（Math）**
**思想**：利用数学规律或公式优化算法。  
**常见方法**：
- 质数判断（试除法、埃拉托斯特尼筛法）。
- 最大公约数（GCD，欧几里得算法）。  

**典型应用**：
- 斐波那契数列（矩阵快速幂）
- 计算质数（LeetCode 204）
- 约瑟夫环问题  

**伪代码（欧几里得算法）**：
```python
def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
```

---

## **10. 随机化（Randomized）**
**思想**：利用随机性避免最坏情况或近似求解。  
**典型应用**：
- 快速排序（随机选择枢轴）
- 蒙特卡洛方法（近似计算 π）
- 哈希表（避免冲突）  

**伪代码（快速排序随机化）**：
```python
import random
def quicksort(nums):
    pivot = random.choice(nums)  # 随机选择枢轴
    left = [x for x in nums if x < pivot]
    right = [x for x in nums if x > pivot]
    return quicksort(left) + [pivot] + quicksort(right)
```

---

## **总结：如何选择算法思想？**
| 问题类型                     | 推荐思想               |
|------------------------------|------------------------|
| 子问题重复（如斐波那契）     | 动态规划（DP）         |
| 需要全局最优（如最短路径）   | 贪心或 BFS             |
| 穷举所有可能（如排列组合）   | 回溯                   |
| 有序数据查找（如二分搜索）   | 分治                   |
| 子数组/子串问题              | 滑动窗口或双指针       |

掌握这些核心思想后，可以灵活组合它们解决复杂问题！ 🚀